From a89d31e899be6d5d1be4db647f5aafd26883c422 Mon Sep 17 00:00:00 2001
From: bigbiff <bigbiff@teamw.in>
Date: Tue, 18 Jan 2022 18:55:46 -0500
Subject: [PATCH] fscrypt: move functionality to libvold

- implement keystore2 changes
- implement keydescriptor
- implement new gatekeeper response
- remove keystore_auth
- general cleanup of unused code

Change-Id: Ib92344c11db2be9bb33d1e527ea023f6890b3747
---
 Android.bp           |   75 +++-
 Decrypt.cpp          | 1007 ++++++++++++++++++++++++++++++++++++++++++
 Decrypt.h            |   43 ++
 FsCrypt.cpp          |   46 +-
 FsCrypt.h            |    2 +
 HashPassword.cpp     |  117 +++++
 HashPassword.h       |   44 ++
 KeyStorage.cpp       |  195 ++++----
 KeyStorage.h         |    3 +
 KeyUtil.cpp          |   20 +-
 Keymaster.cpp        |    2 +-
 KeystoreInfo.cpp     |   79 ++++
 KeystoreInfo.hpp     |   32 ++
 MetadataCrypt.cpp    |   44 +-
 Utils.cpp            |    1 +
 Weaver1.cpp          |  128 ++++++
 Weaver1.h            |   64 +++
 cryptfs.cpp          |    2 +-
 cryptfs.h            |    1 +
 fscrypt-common.h     |    9 +
 fscrypt_policy.cpp   |  160 +++++++
 fscrypt_policy.h     |   87 ++++
 fscryptpolicyget.cpp |   47 ++
 23 files changed, 2077 insertions(+), 131 deletions(-)
 create mode 100755 Decrypt.cpp
 create mode 100755 Decrypt.h
 create mode 100644 HashPassword.cpp
 create mode 100644 HashPassword.h
 create mode 100755 KeystoreInfo.cpp
 create mode 100755 KeystoreInfo.hpp
 create mode 100644 Weaver1.cpp
 create mode 100644 Weaver1.h
 create mode 100755 fscrypt-common.h
 create mode 100755 fscrypt_policy.cpp
 create mode 100755 fscrypt_policy.h
 create mode 100755 fscryptpolicyget.cpp

diff --git a/Android.bp b/Android.bp
index d2c6ffc..d100dd2 100644
--- a/Android.bp
+++ b/Android.bp
@@ -12,6 +12,8 @@ cc_defaults {
         "-Wno-missing-field-initializers",
         "-Wno-unused-parameter",
         "-Wno-unused-variable",
+        "-Wno-macro-redefined",
+        "-DUSE_FSCRYPT_POLICY_V1=1"
     ],
 
     clang: true,
@@ -61,7 +63,6 @@ cc_defaults {
         "libincfs",
         "libhidlbase",
         "libkeyutils",
-        "liblog",
         "liblogwrap",
         "libselinux",
         "libsysutils",
@@ -109,16 +110,22 @@ cc_library_static {
         "vold_default_flags",
         "vold_default_libs",
     ],
-
+    include_dirs: [
+        "system/core/gatekeeperd/include"
+    ],
     srcs: [
         "AppFuseUtil.cpp",
         "Benchmark.cpp",
         "Checkpoint.cpp",
+        "cryptfs.cpp",
         "CryptoType.cpp",
+        "Decrypt.cpp",
         "Devmapper.cpp",
         "EncryptInplace.cpp",
         "FileDeviceUtils.cpp",
         "FsCrypt.cpp",
+        "fscrypt_policy.cpp",
+        "HashPassword.cpp",
         "IdleMaint.cpp",
         "KeyBuffer.cpp",
         "KeyStorage.cpp",
@@ -136,7 +143,7 @@ cc_library_static {
         "VoldNativeServiceValidation.cpp",
         "VoldUtil.cpp",
         "VolumeManager.cpp",
-        "cryptfs.cpp",
+        "Weaver1.cpp",
         "fs/Exfat.cpp",
         "fs/Ext4.cpp",
         "fs/F2fs.cpp",
@@ -164,11 +171,29 @@ cc_library_static {
         },
     },
     shared_libs: [
+        "android.hardware.confirmationui@1.0",
+        "android.hardware.gatekeeper@1.0",
         "android.hardware.health.storage@1.0",
         "android.hardware.health.storage-V1-ndk_platform",
+        "android.hardware.keymaster@4.1",
+        "android.hardware.security.keymint-V1-ndk_platform",
+        "android.hardware.weaver@1.0",
+        "android.security.apc-ndk_platform",
         "android.system.keystore2-V1-ndk_platform",
+        "android.system.keystore2-V1-ndk_platform",
+        "android.security.authorization-ndk_platform",
         "android.security.maintenance-ndk_platform",
+        "libbinder",
         "libbinder_ndk",
+        "libgatekeeper",
+        "libgatekeeper_aidl",
+        "libhardware",
+        "libhidlbase",
+        "liblog",
+        "libchrome",
+        "libkeymaster4_1support",
+        "libkeystoreinfo",
+        "libkeystore-attestation-application-id",
         "libkeymint_support",
     ],
     whole_static_libs: [
@@ -301,3 +326,47 @@ filegroup {
     ],
     path: "binder",
 }
+
+cc_library {
+    name: "libkeystoreinfo",
+    host_supported: true,
+    cflags: [
+        "-Wno-unused-parameter",
+        "-Wno-unused-variable"
+    ],
+    include_dirs: [
+        "external/sqlite/dist/",
+        "system/vold"
+    ],
+    recovery_available: true,
+    srcs: [
+        "KeystoreInfo.cpp"
+    ],
+    shared_libs: [
+        "libsqlite"
+    ],
+    system_shared_libs: [
+        "libc", 
+        "libdl",
+        ],
+}
+
+cc_binary {
+    name: "fscryptpolicyget",
+    defaults: [
+        "vold_default_flags",
+        "vold_default_libs"
+    ],
+
+    srcs: ["fscryptpolicyget.cpp"],
+    static_libs: ["libvold"],
+
+    shared_libs: [
+        "android.hardware.health.storage@1.0",
+        "android.hardware.health.storage-V1-ndk_platform",
+        "android.system.keystore2-V1-ndk_platform",
+        "android.security.maintenance-ndk_platform",
+        "libbinder_ndk",
+        "libkeymint_support",
+    ]
+}
diff --git a/Decrypt.cpp b/Decrypt.cpp
new file mode 100755
index 0000000..60fedd3
--- /dev/null
+++ b/Decrypt.cpp
@@ -0,0 +1,1007 @@
+/*
+ * Copyright (C) 2016 - 2020 The TeamWin Recovery Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "Decrypt.h"
+#include "FsCrypt.h"
+#include <fscrypt/fscrypt.h>
+
+#include <map>
+#include <string>
+
+#include <errno.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <sys/stat.h>
+#include <sys/types.h>
+
+#include <keyutils.h>
+#include "Weaver1.h"
+#include "cutils/properties.h"
+
+#include <openssl/sha.h>
+#include <openssl/aes.h>
+#include <openssl/evp.h>
+#include <openssl/rand.h>
+
+#include <dirent.h>
+#include <stdio.h>
+#include <stdint.h>
+#include <string.h>
+#include <sys/types.h>
+#include <fstream>
+#include <future>
+#include <algorithm>
+#include <chrono>
+
+#include <android/binder_manager.h>
+#include <android-base/file.h>
+#include <android-base/logging.h>
+#include <base/threading/platform_thread.h>
+#include <android/hardware/confirmationui/1.0/types.h>
+#include <aidl/android/hardware/security/keymint/HardwareAuthToken.h>
+#include <aidl/android/security/authorization/IKeystoreAuthorization.h>
+#include <aidl/android/security/apc/BnConfirmationCallback.h>
+#include <aidl/android/system/keystore2/IKeystoreService.h>
+#include <aidl/android/system/keystore2/ResponseCode.h>
+#include <android/hardware/gatekeeper/1.0/IGatekeeper.h>
+
+#include <binder/IServiceManager.h>
+#include <binder/IPCThreadState.h>
+#include <hardware/hw_auth_token.h>
+
+#include <gatekeeper/GateKeeperResponse.h>
+
+#include <keystore/keystore.h>
+#include <keystore/keystore_client.h>
+#include <keystore/KeystoreResponse.h>
+#include <keystore/keystore_hidl_support.h>
+#include <keystore/keystore_return_types.h>
+#include <keystore/keymaster_types.h>
+#include <keymasterV4_1/Keymaster.h>
+#include <keystore/OperationResult.h>
+#include <keymint_support/authorization_set.h>
+#include <keymasterV4_1/keymaster_utils.h>
+
+extern "C" {
+#include "crypto_scrypt.h"
+}
+
+#include "fscrypt_policy.h"
+#include "fscrypt-common.h"
+#include "HashPassword.h"
+#include "KeystoreInfo.hpp"
+#include "KeyStorage.h"
+#include "android/os/IVold.h"
+
+namespace apc = ::aidl::android::security::apc;
+namespace keymint = ::aidl::android::hardware::security::keymint;
+namespace ks2 = ::aidl::android::system::keystore2;
+
+using ::aidl::android::hardware::security::keymint::HardwareAuthenticatorType;
+using ::aidl::android::hardware::security::keymint::HardwareAuthToken;
+using aidl::android::system::keystore2::IKeystoreService;
+using android::security::keymaster::OperationResult;
+using android::hardware::keymaster::V4_1::support::blob2hidlVec;
+using android::hardware::gatekeeper::V1_0::GatekeeperResponse;
+using GKResponse = ::android::service::gatekeeper::GateKeeperResponse;
+
+inline std::string hidlVec2String(const ::keystore::hidl_vec<uint8_t>& value) {
+    return std::string(reinterpret_cast<const std::string::value_type*>(&value[0]), value.size());
+}
+
+static bool lookup_ref_key_internal(std::map<userid_t, android::fscrypt::EncryptionPolicy> key_map, const uint8_t* policy, userid_t* user_id) {
+#ifdef USE_FSCRYPT_POLICY_V1
+	char policy_string_hex[FS_KEY_DESCRIPTOR_SIZE_HEX];
+	char key_map_hex[FS_KEY_DESCRIPTOR_SIZE_HEX];
+	bytes_to_hex(policy, FS_KEY_DESCRIPTOR_SIZE, policy_string_hex);
+#else
+	char policy_string_hex[FSCRYPT_KEY_IDENTIFIER_HEX_SIZE];
+	char key_map_hex[FSCRYPT_KEY_IDENTIFIER_HEX_SIZE];
+	bytes_to_hex(policy, FSCRYPT_KEY_IDENTIFIER_SIZE, policy_string_hex);
+#endif
+
+    for (std::map<userid_t, android::fscrypt::EncryptionPolicy>::iterator it=key_map.begin(); it!=key_map.end(); ++it) {
+#ifdef USE_FSCRYPT_POLICY_V1
+		bytes_to_hex(reinterpret_cast<const uint8_t*>(&it->second.key_raw_ref[0]), FS_KEY_DESCRIPTOR_SIZE, key_map_hex);
+#else
+		bytes_to_hex(reinterpret_cast<const uint8_t*>(&it->second.key_raw_ref[0]), FSCRYPT_KEY_IDENTIFIER_SIZE, key_map_hex);
+#endif
+		std::string key_map_hex_string = std::string(key_map_hex);
+		if (key_map_hex_string == policy_string_hex) {
+            *user_id = it->first;
+            return true;
+        }
+    }
+    return false;
+}
+
+#ifdef USE_FSCRYPT_POLICY_V1
+extern "C" bool lookup_ref_key(fscrypt_policy_v1* fep, uint8_t* policy_type) {
+#else
+extern "C" bool lookup_ref_key(fscrypt_policy_v2* fep, uint8_t* policy_type) {
+#endif
+	userid_t user_id = 0;
+	std::string policy_type_string;
+
+#ifdef USE_FSCRYPT_POLICY_V1
+	char policy_hex[FS_KEY_DESCRIPTOR_SIZE_HEX];
+	bytes_to_hex(fep->master_key_descriptor, FS_KEY_DESCRIPTOR_SIZE, policy_hex);
+	if (std::strncmp((const char*)fep->master_key_descriptor, de_key_raw_ref.c_str(), FS_KEY_DESCRIPTOR_SIZE) == 0) {
+		policy_type_string = SYSTEM_DE_FSCRYPT_POLICY;
+		memcpy(policy_type, policy_type_string.data(), policy_type_string.size());
+		return true;
+	}
+    if (!lookup_ref_key_internal(s_de_policies, fep->master_key_descriptor, &user_id)) {
+        if (!lookup_ref_key_internal(s_ce_policies, fep->master_key_descriptor, &user_id)) {
+            return false;
+		} else {
+			policy_type_string = USER_CE_FSCRYPT_POLICY + std::to_string(user_id);
+		}
+    } else {
+			policy_type_string = USER_DE_FSCRYPT_POLICY + std::to_string(user_id);
+	}
+#else
+	char policy_hex[FSCRYPT_KEY_IDENTIFIER_HEX_SIZE];
+	bytes_to_hex(fep->master_key_identifier, FSCRYPT_KEY_IDENTIFIER_SIZE, policy_hex);
+	if (std::strncmp((const char*)fep->master_key_identifier, de_key_raw_ref.c_str(), FSCRYPT_KEY_IDENTIFIER_SIZE) == 0) {
+		policy_type_string = SYSTEM_DE_FSCRYPT_POLICY;
+		memcpy(policy_type, policy_type_string.data(), policy_type_string.size());
+		return true;
+	}
+    if (!lookup_ref_key_internal(s_de_policies, fep->master_key_identifier, &user_id)) {
+        if (!lookup_ref_key_internal(s_ce_policies, fep->master_key_identifier, &user_id)) {
+            return false;
+		} else {
+			policy_type_string = USER_CE_FSCRYPT_POLICY + std::to_string(user_id);
+		}
+    } else {
+			policy_type_string = USER_DE_FSCRYPT_POLICY + std::to_string(user_id);
+	}
+#endif
+
+	memcpy(policy_type, policy_type_string.data(), policy_type_string.size());
+	printf("storing policy type: %s\n", policy_type);
+    return true;
+}
+
+extern "C" bool lookup_ref_tar(const uint8_t* policy_type, uint8_t* policy) {
+	std::string policy_type_string = std::string((char *) policy_type);
+#ifdef USE_FSCRYPT_POLICY_V1
+	char policy_hex[FS_KEY_DESCRIPTOR_SIZE_HEX];
+	bytes_to_hex(policy_type, FS_KEY_DESCRIPTOR_SIZE, policy_hex);
+#else
+	char policy_hex[FSCRYPT_KEY_IDENTIFIER_HEX_SIZE];
+	bytes_to_hex(policy_type, FSCRYPT_KEY_IDENTIFIER_SIZE, policy_hex);
+#endif
+
+#ifdef USE_FSCRYPT_POLICY_V1
+	if (policy_type_string.substr(0,1) != FSCRYPT_V1) {
+#else
+	if (policy_type_string.substr(0,1) != FSCRYPT_V2) {
+#endif
+        printf("Unexpected version: %d\n", policy_type[0]);
+        return false;
+    }
+
+	if (policy_type_string.substr(1, 2) == SYSTEM_DE_KEY) {
+        memcpy(policy, de_key_raw_ref.data(), de_key_raw_ref.size());
+        return true;
+    }
+
+    std::string raw_ref;
+
+	if (policy_type_string.substr(1, 1) == USER_DE_KEY) {
+		userid_t user_id = std::stoi(policy_type_string.substr(3, 4).c_str());
+        if (lookup_key_ref(s_de_policies, user_id, &raw_ref)) {
+            memcpy(policy, raw_ref.data(), raw_ref.size());
+        } else
+            return false;
+    } else if (policy_type_string.substr(1, 1) == USER_CE_KEY) {
+		userid_t user_id = std::stoi(policy_type_string.substr(3, 4).c_str());
+        if (lookup_key_ref(s_ce_policies, user_id, &raw_ref)) {
+            memcpy(policy, raw_ref.data(), raw_ref.size());
+        } else
+            return false;
+    } else {
+        printf("unknown policy type: %s\n", policy_type);
+        return false;
+    }
+    return true;
+}
+
+extern "C" bool Decrypt_DE() {
+	printf("Attempting to initialize DE keys\n");
+	if (!fscrypt_initialize_systemwide_keys()) { // this deals with the overarching device encryption
+		printf("fscrypt_initialize_systemwide_keys returned fail\n");
+		return false;
+	}
+	if (!fscrypt_init_user0()) {
+		printf("fscrypt_init_user0 returned fail\n");
+		return false;
+	}
+	return true;
+}
+
+// Crappy functions for debugging, please ignore unless you need to debug
+// void output_hex(const std::string& in) {
+// 	const char *buf = in.data();
+// 	char hex[in.size() * 2 + 1];
+// 	unsigned int index;
+// 	for (index = 0; index < in.size(); index++)
+// 		sprintf(&hex[2 * index], "%02X", buf[index]);
+// }
+
+// void output_hex(const char* buf, const int size) {
+// 	char hex[size * 2 + 1];
+// 	int index;
+// 	for (index = 0; index < size; index++)
+// 		sprintf(&hex[2 * index], "%02X", buf[index]);
+// 	printf("%s", hex);
+// }
+
+// void output_hex(const unsigned char* buf, const int size) {
+// 	char hex[size * 2 + 1];
+// 	int index;
+// 	for (index = 0; index < size; index++)
+// 		sprintf(&hex[2 * index], "%02X", buf[index]);
+// 	printf("%s", hex);
+// }
+
+// void output_hex(std::vector<uint8_t>* vec) {
+// 	char hex[3];
+// 	unsigned int index;
+// 	for (index = 0; index < vec->size(); index++) {
+// 		sprintf(&hex[0], "%02X", vec->at(index));
+// 		printf("%s", hex);
+// 	}
+// }
+
+/* This is the structure of the data in the password data (*.pwd) file which the structure can be found
+ * https://android.googlesource.com/platform/frameworks/base/+/android-8.0.0_r23/services/core/java/com/android/server/locksettings/SyntheticPasswordManager.java#187 */
+struct password_data_struct {
+	int password_type;
+	unsigned char scryptN;
+	unsigned char scryptR;
+	unsigned char scryptP;
+	int salt_len;
+	void* salt;
+	int handle_len;
+	void* password_handle;
+};
+
+/* C++ replacement for
+ * https://android.googlesource.com/platform/frameworks/base/+/android-8.0.0_r23/services/core/java/com/android/server/locksettings/SyntheticPasswordManager.java#764 */
+bool Get_Password_Data(const std::string& spblob_path, const std::string& handle_str, password_data_struct *pwd) {
+	printf("fscrypt::Get_Password_Data::1\n");
+	std::string pwd_file = spblob_path + handle_str + ".pwd";
+	std::string pwd_data;
+	if (!android::base::ReadFileToString(pwd_file, &pwd_data)) {
+		printf("Failed to read '%s'\n", pwd_file.c_str());
+		return false;
+	}
+	// output_hex(pwd_data.data(), pwd_data.size());printf("\n");
+	const int* intptr = (const int*)pwd_data.data();
+	pwd->password_type = *intptr;
+	endianswap(&pwd->password_type);
+	//printf("password type %i\n", pwd->password_type); // 2 was PIN, 1 for pattern, 2 also for password, -1 for default password
+	const unsigned char* byteptr = (const unsigned char*)pwd_data.data() + sizeof(int);
+	pwd->scryptN = *byteptr;
+	byteptr++;
+	pwd->scryptR = *byteptr;
+	byteptr++;
+	pwd->scryptP = *byteptr;
+	byteptr++;
+	intptr = (const int*)byteptr;
+	pwd->salt_len = *intptr;
+	endianswap(&pwd->salt_len);
+	if (pwd->salt_len != 0) {
+		pwd->salt = malloc(pwd->salt_len);
+		if (!pwd->salt) {
+			printf("Get_Password_Data malloc salt\n");
+			return false;
+		}
+		memcpy(pwd->salt, intptr + 1, pwd->salt_len);
+		intptr++;
+		byteptr = (const unsigned char*)intptr;
+		byteptr += pwd->salt_len;
+	} else {
+		printf("Get_Password_Data salt_len is 0\n");
+		return false;
+	}
+	intptr = (const int*)byteptr;
+	pwd->handle_len = *intptr;
+	endianswap(&pwd->handle_len);
+	if (pwd->handle_len != 0) {
+		pwd->password_handle = malloc(pwd->handle_len);
+		if (!pwd->password_handle) {
+			printf("Get_Password_Data malloc password_handle\n");
+			return false;
+		}
+		memcpy(pwd->password_handle, intptr + 1, pwd->handle_len);
+	} else {
+		printf("Get_Password_Data handle_len is 0\n");
+		// Not an error if using weaver
+	}
+	return true;
+}
+
+/* C++ replacement for
+ * https://android.googlesource.com/platform/frameworks/base/+/android-8.0.0_r23/services/core/java/com/android/server/locksettings/SyntheticPasswordManager.java#765
+ * called here
+ * https://android.googlesource.com/platform/frameworks/base/+/android-8.0.0_r23/services/core/java/com/android/server/locksettings/SyntheticPasswordManager.java#1050 */
+bool Get_Password_Token(const password_data_struct *pwd, const std::string& Password, unsigned char* password_token) {
+	if (!password_token) {
+		printf("password_token is null\n");
+		return false;
+	}
+	unsigned int N = 1 << pwd->scryptN;
+	unsigned int r = 1 << pwd->scryptR;
+	unsigned int p = 1 << pwd->scryptP;
+	//printf("N %i r %i p %i\n", N, r, p);
+	int ret = crypto_scrypt(reinterpret_cast<const uint8_t*>(Password.data()), Password.size(),
+                          reinterpret_cast<const uint8_t*>(pwd->salt), pwd->salt_len,
+                          N, r, p,
+                          password_token, 32);
+	if (ret != 0) {
+		printf("scrypt error\n");
+		return false;
+	}
+	return true;
+}
+
+// Data structure for the *.weaver file, see Get_Weaver_Data below
+struct weaver_data_struct {
+	unsigned char version;
+	int slot;
+};
+
+/* C++ replacement for
+ * https://android.googlesource.com/platform/frameworks/base/+/android-8.0.0_r23/services/core/java/com/android/server/locksettings/SyntheticPasswordManager.java#501
+ * called here
+ * https://android.googlesource.com/platform/frameworks/base/+/android-8.0.0_r23/services/core/java/com/android/server/locksettings/SyntheticPasswordManager.java#768 */
+bool Get_Weaver_Data(const std::string& spblob_path, const std::string& handle_str, weaver_data_struct *wd) {
+	printf("Get_Weaver_Data\n");
+	std::string weaver_file = spblob_path + handle_str + ".weaver";
+	std::string weaver_data;
+	if (!android::base::ReadFileToString(weaver_file, &weaver_data)) {
+		printf("Failed to read '%s'\n", weaver_file.c_str());
+		return false;
+	}
+	// output_hex(weaver_data.data(), weaver_data.size());printf("\n");
+	const unsigned char* byteptr = (const unsigned char*)weaver_data.data();
+	wd->version = *byteptr;
+	// printf("weaver version %i\n", wd->version);
+	const int* intptr = (const int*)weaver_data.data() + sizeof(unsigned char);
+	wd->slot = *intptr;
+	//endianswap(&wd->slot); not needed
+	// printf("weaver slot %i\n", wd->slot);
+	return true;
+}
+
+namespace android {
+
+/* These next 2 functions try to get the keystore service 50 times because
+ * the keystore is not always ready when TWRP boots */
+android::sp<IBinder> getKeystoreBinder() {
+	android::sp<IServiceManager> sm = android::defaultServiceManager();
+    return sm->getService(String16("android.security.keystore"));
+}
+
+android::sp<IBinder> getKeystoreBinderRetry() {
+	printf("Starting keystore...\n");
+    property_set("ctl.start", "keystore");
+	int retry_count = 50;
+	android::sp<IBinder> binder = getKeystoreBinder();
+	while (binder == NULL && retry_count) {
+		printf("Waiting for keystore service... %i\n", retry_count--);
+		sleep(1);
+		binder = getKeystoreBinder();
+	}
+	return binder;
+}
+
+namespace keystore {
+
+#define SYNTHETIC_PASSWORD_VERSION_V1 1
+#define SYNTHETIC_PASSWORD_VERSION_V2 2
+#define SYNTHETIC_PASSWORD_VERSION_V3 3
+#define SYNTHETIC_PASSWORD_PASSWORD_BASED 0
+#define SYNTHETIC_PASSWORD_KEY_PREFIX "USRSKEY_synthetic_password_"
+#define USR_PRIVATE_KEY_PREFIX "USRPKEY_synthetic_password_"
+#define PASSWORD_TOKEN_SIZE 32
+#define GK_ERROR *gkResponse = GKResponse::error(), Status::ok()
+
+	ks2::KeyDescriptor keyDescriptor(const std::string& alias) {
+		return {
+			.domain = ks2::Domain::SELINUX,
+			.nspace = NAMESPACE_LOCKSETTINGS,
+			.alias = alias,
+			.blob = {},
+		};
+	}
+
+	int unwrapError(const ndk::ScopedAStatus& status) {
+		if (status.isOk()) return 0;
+		if (status.getExceptionCode() == EX_SERVICE_SPECIFIC) {
+			return status.getServiceSpecificError();
+		} else {
+			return static_cast<int>(ks2::ResponseCode::SYSTEM_ERROR);
+		}
+	}
+
+	void copySqliteDb() {
+		std::string keystore_path = "/tmp/misc/keystore/";
+		std::string dst = keystore_path + "persistent.sqlite";
+		std::string src = "/data/misc/keystore/persistent.sqlite";
+		std::ifstream srcif(src.c_str(), std::ios::binary);
+		std::ofstream dstof(dst.c_str(), std::ios::binary);
+		printf("copying '%s' to '%s'\n", src.c_str(), dst.c_str());
+		dstof << srcif.rdbuf();
+		srcif.close();
+		dstof.close();
+	}
+
+	/* C++ replacement for function of the same name
+	* https://android.googlesource.com/platform/frameworks/base/+/android-8.0.0_r23/services/core/java/com/android/server/locksettings/SyntheticPasswordManager.java#867
+	* returning an empty string indicates an error */
+	std::string unwrapSyntheticPasswordBlob(const std::string& spblob_path, const std::string& handle_str, const userid_t user_id,
+		const void* application_id, const size_t application_id_size, uint32_t auth_token_len) {
+		printf("Attempting to unwrap synthetic password blob\n");
+		std::string disk_decryption_secret_key = "";
+
+		android::ProcessState::self()->startThreadPool();
+
+		// Read the data from the .spblob file per: https://android.googlesource.com/platform/frameworks/base/+/android-8.0.0_r23/services/core/java/com/android/server/locksettings/SyntheticPasswordManager.java#869
+		std::string spblob_file = spblob_path + handle_str + ".spblob";
+		std::string spblob_data;
+		if (!android::base::ReadFileToString(spblob_file, &spblob_data)) {
+			printf("Failed to read '%s'\n", spblob_file.c_str());
+			return disk_decryption_secret_key;
+		}
+		unsigned char* byteptr = (unsigned char*)spblob_data.data();
+		if (*byteptr != SYNTHETIC_PASSWORD_VERSION_V2 && *byteptr != SYNTHETIC_PASSWORD_VERSION_V1
+				&& *byteptr != SYNTHETIC_PASSWORD_VERSION_V3) {
+			printf("Unsupported synthetic password version %i\n", *byteptr);
+			return disk_decryption_secret_key;
+		}
+		const unsigned char* synthetic_password_version = byteptr;
+		byteptr++;
+		if (*byteptr != SYNTHETIC_PASSWORD_PASSWORD_BASED) {
+			printf("spblob data is not SYNTHETIC_PASSWORD_PASSWORD_BASED\n");
+			return disk_decryption_secret_key;
+		}
+		byteptr++; // Now we're pointing to the blob data itself
+		if (*synthetic_password_version == SYNTHETIC_PASSWORD_VERSION_V2
+				|| *synthetic_password_version == SYNTHETIC_PASSWORD_VERSION_V3) {
+			printf("spblob v2 / v3\n");
+			/* Version 2 / 3 of the spblob is basically the same as version 1, but the order of getting the intermediate key and disk decryption key have been flip-flopped
+			* as seen in https://android.googlesource.com/platform/frameworks/base/+/5025791ac6d1538224e19189397de8d71dcb1a12
+			*/
+			/* First decrypt call found in
+			* https://android.googlesource.com/platform/frameworks/base/+/android-8.1.0_r18/services/core/java/com/android/server/locksettings/SyntheticPasswordCrypto.java#135
+			* We will use https://android.googlesource.com/platform/frameworks/base/+/android-8.0.0_r23/keystore/java/android/security/keystore/AndroidKeyStoreCipherSpiBase.java
+			* and https://android.googlesource.com/platform/frameworks/base/+/android-8.0.0_r23/keystore/java/android/security/keystore/AndroidKeyStoreAuthenticatedAESCipherSpi.java
+			* First we set some algorithm parameters as seen in two places:
+			* https://android.googlesource.com/platform/frameworks/base/+/android-8.0.0_r23/keystore/java/android/security/keystore/AndroidKeyStoreAuthenticatedAESCipherSpi.java#297
+			* https://android.googlesource.com/platform/frameworks/base/+/android-8.0.0_r23/keystore/java/android/security/keystore/AndroidKeyStoreAuthenticatedAESCipherSpi.java#216 */
+			// When using secdis (aka not weaver) you must supply an auth token to the keystore prior to the begin operation
+			int32_t ret;
+			size_t maclen = 128;
+			unsigned char* iv = (unsigned char*)byteptr; // The IV is the first 12 bytes of the spblob
+			::keystore::hidl_vec<uint8_t> iv_hidlvec;
+			iv_hidlvec.setToExternal((unsigned char*)byteptr, 12);
+			// printf("iv: "); output_hex((const unsigned char*)iv, 12); printf("\n");
+
+			KeystoreInfo keystore_info;
+			std::string handle = keystore_info.getHandle(user_id);
+			std::string keystore_alias = keystore_info.getAlias(handle);
+			int32_t error_code;
+			unsigned char* cipher_text = (unsigned char*)byteptr + 12; // The cipher text comes immediately after the IV
+			std::string cipher_text_str(byteptr, byteptr + spblob_data.size() - 14);
+			::keystore::hidl_vec<uint8_t> cipher_text_hidlvec;
+
+			cipher_text_hidlvec.setToExternal(cipher_text, spblob_data.size() - 14 /* 1 each for version and SYNTHETIC_PASSWORD_PASSWORD_BASED and 12 for the iv */);
+			auto begin_params = keymint::AuthorizationSetBuilder()
+				.Authorization(keymint::TAG_ALGORITHM, ::keymint::Algorithm::AES)
+				.Authorization(::keymint::TAG_BLOCK_MODE, ::keymint::BlockMode::GCM)
+				.Padding(::keymint::PaddingMode::NONE)
+				.Authorization(keymint::TAG_PURPOSE, keymint::KeyPurpose::DECRYPT)
+				.Authorization(::keymint::TAG_NONCE, iv_hidlvec)
+				.Authorization(::keymint::TAG_MAC_LENGTH, maclen);
+
+			ks2::KeyEntryResponse keyEntryResponse;
+			::ndk::SpAIBinder keystoreBinder(AServiceManager_checkService("android.system.keystore2.IKeystoreService/default"));
+			auto keystore = ks2::IKeystoreService::fromBinder(keystoreBinder);
+			auto rc = keystore->getKeyEntry(keyDescriptor(keystore_alias), &keyEntryResponse);
+			if (!rc.isOk()) {
+				auto error = unwrapError(rc);
+				if (ks2::ResponseCode(error) == ks2::ResponseCode::KEY_NOT_FOUND) {
+					printf("key not found\n");
+				} else {
+					printf("Failed to get key entry: %s\n", rc.getDescription().c_str());
+				}
+				return disk_decryption_secret_key;
+			}
+			std::variant<int, ks2::KeyEntryResponse> response = keyEntryResponse;
+			auto keyResponse = std::get<ks2::KeyEntryResponse>(response);
+			ks2::CreateOperationResponse encOperationResponse;
+			auto begin_rc = keyResponse.iSecurityLevel->createOperation(
+				keyResponse.metadata.key, begin_params.vector_data(), true,
+				&encOperationResponse);
+			if (!begin_rc.isOk()) {
+				printf("Begin Operation failed\n");
+				return disk_decryption_secret_key;
+			}
+			std::optional<std::vector<uint8_t>> optPlaintext;
+
+			begin_rc = encOperationResponse.iOperation->finish(cipher_text_hidlvec, {}, &optPlaintext);
+			if (!begin_rc.isOk()) {
+				printf("finish reponse failed");
+				return disk_decryption_secret_key;
+			}
+
+			size_t keystore_result_size = optPlaintext->size();
+			unsigned char* keystore_result = (unsigned char*)malloc(keystore_result_size);
+			if (!keystore_result) {
+				printf("malloc on keystore_result\n");
+				return disk_decryption_secret_key;
+			}
+			memcpy(keystore_result, &optPlaintext->front(), keystore_result_size);
+
+			const unsigned char* intermediate_iv = keystore_result;
+			// printf("intermediate_iv: "); output_hex((const unsigned char*)intermediate_iv, 12); printf("\n");
+			const unsigned char* intermediate_cipher_text = (const unsigned char*)keystore_result + 12; // The cipher text comes immediately after the IV
+			int cipher_size = keystore_result_size - 12;
+			// First we personalize as seen https://android.googlesource.com/platform/frameworks/base/+/android-8.0.0_r23/services/core/java/com/android/server/locksettings/SyntheticPasswordCrypto.java#102
+			void* personalized_application_id = PersonalizedHashBinary(PERSONALISATION_APPLICATION_ID, (const char*)application_id, application_id_size);
+			if (!personalized_application_id) {
+				printf("Unable to obtain personalized_application_id\n");
+				return disk_decryption_secret_key;
+			}
+			// printf("personalized application id: "); output_hex((unsigned char*)personalized_application_id, SHA512_DIGEST_LENGTH); printf("\n");
+			// Now we'll decrypt using openssl AES/GCM/NoPadding
+			OpenSSL_add_all_ciphers();
+			int actual_size=0, final_size=0;
+			EVP_CIPHER_CTX *d_ctx = EVP_CIPHER_CTX_new();
+			const unsigned char* key = (const unsigned char*)personalized_application_id; // The key is the now personalized copy of the application ID
+			// printf("key: "); output_hex((const unsigned char*)key, 32); printf("\n");
+			EVP_DecryptInit(d_ctx, EVP_aes_256_gcm(), key, intermediate_iv);
+			unsigned char* secret_key = (unsigned char*)malloc(cipher_size);
+			if (!secret_key) {
+				printf("malloc failure on secret key\n");
+				return disk_decryption_secret_key;
+			}
+			EVP_DecryptUpdate(d_ctx, secret_key, &actual_size, intermediate_cipher_text, cipher_size);
+			unsigned char tag[AES_BLOCK_SIZE];
+			EVP_CIPHER_CTX_ctrl(d_ctx, EVP_CTRL_GCM_SET_TAG, 16, tag);
+			EVP_DecryptFinal_ex(d_ctx, secret_key + actual_size, &final_size);
+			EVP_CIPHER_CTX_free(d_ctx);
+			free(personalized_application_id);
+			free(keystore_result);
+			int secret_key_real_size = actual_size - 16;
+			// printf("secret key:  "); output_hex((const unsigned char*)secret_key, secret_key_real_size); printf("\n");
+			// The payload data from the keystore update is further personalized at https://android.googlesource.com/platform/frameworks/base/+/android-8.0.0_r23/services/core/java/com/android/server/locksettings/SyntheticPasswordManager.java#153
+			// We now have the disk decryption key!
+			if (*synthetic_password_version == SYNTHETIC_PASSWORD_VERSION_V3) {
+				// V3 uses SP800 instead of SHA512
+				disk_decryption_secret_key = PersonalizedHashSP800(PERSONALIZATION_FBE_KEY, PERSONALISATION_CONTEXT, (const char*)secret_key, secret_key_real_size);
+			} else {
+				disk_decryption_secret_key = PersonalizedHash(PERSONALIZATION_FBE_KEY, (const char*)secret_key, secret_key_real_size);
+			}
+			// printf("disk_decryption_secret_key: '%s'\n", disk_decryption_secret_key.c_str());
+			free(secret_key);
+			return disk_decryption_secret_key;
+		}
+		return disk_decryption_secret_key;
+	}
+}
+// /* C++ replacement for
+//  * https://android.googlesource.com/platform/frameworks/base/+/android-8.0.0_r23/services/core/java/com/android/server/locksettings/SyntheticPasswordManager.java#992
+//  * called here
+//  * https://android.googlesource.com/platform/frameworks/base/+/android-8.0.0_r23/services/core/java/com/android/server/locksettings/SyntheticPasswordManager.java#813 */
+bool Get_Secdis(const std::string& spblob_path, const std::string& handle_str, std::string& secdis_data) {
+	std::string secdis_file = spblob_path + handle_str + ".secdis";
+	if (!android::base::ReadFileToString(secdis_file, &secdis_data)) {
+		printf("Failed to read '%s'\n", secdis_file.c_str());
+		return false;
+	}
+	// output_hex(secdis_data.data(), secdis_data.size());printf("\n");
+	return true;
+}
+
+// // C++ replacement for https://android.googlesource.com/platform/frameworks/base/+/android-8.0.0_r23/services/core/java/com/android/server/locksettings/SyntheticPasswordManager.java#1033
+userid_t fakeUid(const userid_t uid) {
+    return 100000 + uid;
+}
+
+bool Is_Weaver(const std::string& spblob_path, const std::string& handle_str) {
+	printf("Is_Weaver\n");
+	std::string weaver_file = spblob_path + handle_str + ".weaver";
+	struct stat st;
+	if (stat(weaver_file.c_str(), &st) == 0)
+		return true;
+	return false;
+}
+
+bool Free_Return(bool retval, void* weaver_key, password_data_struct* pwd) {
+	printf("Free_Return\n");
+	if (weaver_key)
+		free(weaver_key);
+	if (pwd->salt)
+		free(pwd->salt);
+	if (pwd->password_handle)
+		free(pwd->password_handle);
+	return retval;
+}
+
+// /* Decrypt_User_Synth_Pass is the TWRP C++ equivalent to spBasedDoVerifyCredential
+//  * https://android.googlesource.com/platform/frameworks/base/+/android-8.0.0_r23/services/core/java/com/android/server/locksettings/LockSettingsService.java#1998 */
+bool Decrypt_User_Synth_Pass(const userid_t user_id, const std::string& Password) {
+	printf("Attempting to decrypt user's synthetic password\n");
+	bool retval = false;
+	void* weaver_key = NULL;
+	password_data_struct pwd;
+	pwd.salt = NULL;
+	pwd.salt_len = 0;
+	pwd.password_handle = NULL;
+	pwd.handle_len = 0;
+	char application_id[PASSWORD_TOKEN_SIZE + SHA512_DIGEST_LENGTH];
+
+    uint32_t auth_token_len = 0;
+
+	std::string secret; // this will be the disk decryption key that is sent to vold
+	int token = 0; // there is no token used for this kind of decrypt, key escrow is handled by weaver
+	int flags = android::os::IVold::STORAGE_FLAG_CE;
+	char spblob_path_char[PATH_MAX];
+	sprintf(spblob_path_char, "/data/system_de/%d/spblob/", user_id);
+	std::string spblob_path = spblob_path_char;
+	long handle = 0;
+	// Get the handle: https://android.googlesource.com/platform/frameworks/base/+/android-8.0.0_r23/services/core/java/com/android/server/locksettings/LockSettingsService.java#2017
+	KeystoreInfo keystore_info;
+	std::string handle_str = keystore_info.getHandle(user_id);
+	// Now we begin driving unwrapPasswordBasedSyntheticPassword from: https://android.googlesource.com/platform/frameworks/base/+/android-8.0.0_r23/services/core/java/com/android/server/locksettings/SyntheticPasswordManager.java#758
+	// First we read the password data which contains scrypt parameters
+	if (!Get_Password_Data(spblob_path, handle_str, &pwd)) {
+		printf("Failed to Get_Password_Data\n");
+		return Free_Return(retval, weaver_key, &pwd);
+	}
+	// printf("pwd N %i R %i P %i salt ", pwd.scryptN, pwd.scryptR, pwd.scryptP); output_hex((char*)pwd.salt, pwd.salt_len); printf("\n");
+	unsigned char password_token[PASSWORD_TOKEN_SIZE];
+	// printf("Password: '%s'\n", Password.c_str());
+	// The password token is the password scrypted with the parameters from the password data file
+	printf("fscrypt::GetPassword_Token\n");
+	if (!Get_Password_Token(&pwd, Password, &password_token[0])) {
+		printf("Failed to Get_Password_Token\n");
+		return Free_Return(retval, weaver_key, &pwd);
+	}
+	// output_hex(&password_token[0], PASSWORD_TOKEN_SIZE);printf("\n");
+	if (Is_Weaver(spblob_path, handle_str)) {
+		printf("using weaver\n");
+		// BEGIN PIXEL 2 WEAVER
+		// Get the weaver data from the .weaver file which tells us which slot to use when we ask weaver for the escrowed key
+		// https://android.googlesource.com/platform/frameworks/base/+/android-8.0.0_r23/services/core/java/com/android/server/locksettings/SyntheticPasswordManager.java#768
+		weaver_data_struct wd;
+		if (!Get_Weaver_Data(spblob_path, handle_str, &wd)) {
+			printf("Failed to get weaver data\n");
+			return Free_Return(retval, weaver_key, &pwd);
+		}
+		// The weaver key is the the password token prefixed with "weaver-key" padded to 128 with nulls with the password token appended then SHA512
+		// https://android.googlesource.com/platform/frameworks/base/+/android-8.0.0_r23/services/core/java/com/android/server/locksettings/SyntheticPasswordManager.java#1059
+		weaver_key = PersonalizedHashBinary(PERSONALISATION_WEAVER_KEY, (char*)&password_token[0], PASSWORD_TOKEN_SIZE);
+		if (!weaver_key) {
+			printf("malloc error getting weaver_key\n");
+			return Free_Return(retval, weaver_key, &pwd);
+		}
+		// Now we start driving weaverVerify: https://android.googlesource.com/platform/frameworks/base/+/android-8.0.0_r23/services/core/java/com/android/server/locksettings/SyntheticPasswordManager.java#343
+		// Called from https://android.googlesource.com/platform/frameworks/base/+/android-8.0.0_r23/services/core/java/com/android/server/locksettings/SyntheticPasswordManager.java#776
+		android::vold::Weaver weaver;
+		if (!weaver) {
+			printf("Failed to get weaver service\n");
+			return Free_Return(retval, weaver_key, &pwd);
+		}
+		// Get the key size from weaver service
+		uint32_t weaver_key_size = 0;
+		if (!weaver.GetKeySize(&weaver_key_size)) {
+			printf("Failed to get weaver key size\n");
+			return Free_Return(retval, weaver_key, &pwd);
+		} else {
+			printf("weaver key size is %u\n", weaver_key_size);
+		}
+		// printf("weaver key: "); output_hex((unsigned char*)weaver_key, weaver_key_size); printf("\n");
+		// Send the slot from the .weaver file, the computed weaver key, and get the escrowed key data
+		std::vector<uint8_t> weaver_payload;
+		// TODO: we should return more information about the status including time delays before the next retry
+		if (!weaver.WeaverVerify(wd.slot, weaver_key, &weaver_payload)) {
+			printf("failed to weaver verify\n");
+			return Free_Return(retval, weaver_key, &pwd);
+		}
+		// printf("weaver payload: "); output_hex(&weaver_payload); printf("\n");
+		// Done with weaverVerify
+		// Now we will compute the application ID
+		// https://android.googlesource.com/platform/frameworks/base/+/android-8.0.0_r23/services/core/java/com/android/server/locksettings/SyntheticPasswordManager.java#964
+		// Called from https://android.googlesource.com/platform/frameworks/base/+/android-8.0.0_r23/services/core/java/com/android/server/locksettings/SyntheticPasswordManager.java#780
+		// The escrowed weaver key data is prefixed with "weaver-pwd" padded to 128 with nulls with the weaver payload appended then SHA512
+		void* weaver_secret = PersonalizedHashBinary(PERSONALISATION_WEAVER_PASSWORD, (const char*)weaver_payload.data(), weaver_payload.size());
+		// printf("weaver secret: "); output_hex((unsigned char*)weaver_secret, SHA512_DIGEST_LENGTH); printf("\n");
+		// The application ID is the password token and weaver secret appended to each other
+		memcpy((void*)&application_id[0], (void*)&password_token[0], PASSWORD_TOKEN_SIZE);
+		memcpy((void*)&application_id[PASSWORD_TOKEN_SIZE], weaver_secret, SHA512_DIGEST_LENGTH);
+		// printf("application ID: "); output_hex((unsigned char*)application_id, PASSWORD_TOKEN_SIZE + SHA512_DIGEST_LENGTH); printf("\n");
+		// END PIXEL 2 WEAVER
+	} else {
+		printf("using secdis to decrypt spblob\n");
+		std::string secdis_data;
+		if (!Get_Secdis(spblob_path, handle_str, secdis_data)) {
+			printf("Failed to get secdis data\n");
+			return Free_Return(retval, weaver_key, &pwd);
+		}
+		void* secdiscardable = PersonalizedHashBinary(PERSONALISATION_SECDISCARDABLE, (char*)secdis_data.data(), secdis_data.size());
+		if (!secdiscardable) {
+			printf("malloc error getting secdiscardable\n");
+			return Free_Return(retval, weaver_key, &pwd);
+		}
+		memcpy((void*)&application_id[0], (void*)&password_token[0], PASSWORD_TOKEN_SIZE);
+		memcpy((void*)&application_id[PASSWORD_TOKEN_SIZE], secdiscardable, SHA512_DIGEST_LENGTH);
+
+		int ret = -1;
+		bool request_reenroll = false;
+		android::sp<android::hardware::gatekeeper::V1_0::IGatekeeper> gk_device;
+		gk_device = ::android::hardware::gatekeeper::V1_0::IGatekeeper::getService();
+		if (gk_device == nullptr) {
+			printf("failed to get gatekeeper service\n");
+			return Free_Return(retval, weaver_key, &pwd);
+		}
+		if (pwd.handle_len <= 0) {
+			printf("no password handle supplied\n");
+			return Free_Return(retval, weaver_key, &pwd);
+		}
+		android::hardware::hidl_vec<uint8_t> pwd_handle_hidl;
+		pwd_handle_hidl.setToExternal(const_cast<uint8_t *>((const uint8_t *)pwd.password_handle), pwd.handle_len);
+		void* gk_pwd_token = PersonalizedHashBinary(PERSONALIZATION_USER_GK_AUTH, (char*)&password_token[0], PASSWORD_TOKEN_SIZE);
+		if (!gk_pwd_token) {
+			printf("malloc error getting gatekeeper_key\n");
+			return Free_Return(retval, weaver_key, &pwd);
+		}
+		android::hardware::hidl_vec<uint8_t> gk_pwd_token_hidl;
+		GKResponse gkResponse;
+		gk_pwd_token_hidl.setToExternal(const_cast<uint8_t *>((const uint8_t *)gk_pwd_token), SHA512_DIGEST_LENGTH);
+		android::hardware::Return<void> hwRet =
+			gk_device->verify(fakeUid(user_id), 0 /* challenge */,
+							  pwd_handle_hidl,
+							  gk_pwd_token_hidl,
+							  [&gkResponse]
+								// []
+								(const android::hardware::gatekeeper::V1_0::GatekeeperResponse &rsp) {
+									// ret = static_cast<int>(rsp.code); // propagate errors
+									if (rsp.code >= android::hardware::gatekeeper::V1_0::GatekeeperStatusCode::STATUS_OK) {
+										gkResponse = GKResponse::ok({rsp.data.begin(), rsp.data.end()});
+										const hw_auth_token_t* hwAuthToken =
+											reinterpret_cast<const hw_auth_token_t*>(gkResponse.payload().data());
+										HardwareAuthToken authToken;
+										authToken.timestamp.milliSeconds = betoh64(hwAuthToken->timestamp);
+										authToken.challenge = hwAuthToken->challenge;
+										authToken.userId = hwAuthToken->user_id;
+										authToken.authenticatorId = hwAuthToken->authenticator_id;
+										authToken.authenticatorType = static_cast<HardwareAuthenticatorType>(
+												betoh32(hwAuthToken->authenticator_type));
+										authToken.mac.assign(&hwAuthToken->hmac[0], &hwAuthToken->hmac[32]);
+										AIBinder* authzAIBinder = AServiceManager_getService("android.security.authorization");
+										::ndk::SpAIBinder binder(authzAIBinder);
+										auto service = aidl::android::security::authorization::IKeystoreAuthorization::fromBinder(binder);
+										if (service == NULL) {
+											printf("error: could not connect to keystore service\n");
+											ALOGE("error: could not connect to keystore service\n");
+										}
+										auto binder_result = service->addAuthToken(authToken);
+									}
+								}
+							 );
+		free(gk_pwd_token);
+		if (!hwRet.isOk()) {
+			printf("gatekeeper verification failed\n");
+			return Free_Return(retval, weaver_key, &pwd);
+		}
+	}
+	// Now we will handle https://android.googlesource.com/platform/frameworks/base/+/android-8.0.0_r23/services/core/java/com/android/server/locksettings/SyntheticPasswordManager.java#816
+	// Plus we will include the last bit that computes the disk decrypt key found in:
+	// https://android.googlesource.com/platform/frameworks/base/+/android-8.0.0_r23/services/core/java/com/android/server/locksettings/SyntheticPasswordManager.java#153
+	secret = android::keystore::unwrapSyntheticPasswordBlob(spblob_path, handle_str, user_id, (const void*)&application_id[0], 
+		PASSWORD_TOKEN_SIZE + SHA512_DIGEST_LENGTH, auth_token_len);
+	if (!secret.size()) {
+		printf("failed to unwrapSyntheticPasswordBlob\n");
+		return Free_Return(retval, weaver_key, &pwd);
+	}
+
+	printf("Attempting to unlock user storage\n");
+	if (!fscrypt_unlock_user_key(user_id, token, secret)) {
+		printf("fscrypt_unlock_user_key returned fail\n");
+		return Free_Return(retval, weaver_key, &pwd);
+	}
+
+	printf("Attempting to prepare user storage\n");
+
+	if (!fscrypt_prepare_user_storage("", user_id, 0, flags)) {
+		printf("failed to fscrypt_prepare_user_storage\n");
+		return Free_Return(retval, weaver_key, &pwd);
+	}
+	printf("User %i Decrypted Successfully!\n", user_id);
+	retval = true;
+	return Free_Return(retval, weaver_key, &pwd);
+}
+
+extern "C" int Get_Password_Type(const userid_t user_id, std::string& filename) {
+	struct stat st;
+	char spblob_path_char[PATH_MAX];
+	sprintf(spblob_path_char, "/data/system_de/%d/spblob/", user_id);
+	if (stat(spblob_path_char, &st) == 0) {
+		std::string spblob_path = spblob_path_char;
+		KeystoreInfo keystore_info;
+		std::string handle_str = keystore_info.getHandle(user_id);
+		printf("Handle is '%s'\n", handle_str.c_str());
+		password_data_struct pwd;
+		if (!Get_Password_Data(spblob_path, handle_str, &pwd)) {
+			printf("Failed to Get_Password_Data\n");
+			return 0;
+		}
+		// In Android type 1 is pattern
+		// In Android <11 type 2 is PIN or password
+		// In Android 11+ type 3 is PIN and type 4 is password
+		if (pwd.password_type == 2) {
+			printf("password type: password/PIN\n");
+			return 1; // In TWRP this means password or PIN (Android <11)
+		} else if (pwd.password_type == 4) {
+			printf("password type: password\n");
+			return 1; // In TWRP this means password
+		} else if (pwd.password_type == 1) {
+			printf("password type: pattern\n");
+			return 2; // In TWRP this means pattern
+		} else if (pwd.password_type == 3) {
+			printf("password type: PIN\n");
+			return 3; // In TWRP this means PIN
+		}
+		printf("using default password\n");
+		return 0; // We'll try the default password
+	}
+	std::string path;
+    if (user_id == 0) {
+		path = "/data/system/";
+	} else {
+		char user_id_str[5];
+		sprintf(user_id_str, "%i", user_id);	
+		path = "/data/system/users/";
+		path += user_id_str;
+		path += "/";
+	}
+	filename = path + "gatekeeper.password.key";
+	if (stat(filename.c_str(), &st) == 0 && st.st_size > 0)
+		return 1;
+	filename = path + "gatekeeper.pattern.key";
+	if (stat(filename.c_str(), &st) == 0 && st.st_size > 0)
+		return 2;
+	printf("Unable to locate gatekeeper password file '%s'\n", filename.c_str());
+	filename = "";
+	return 0;
+}
+
+extern "C" bool Decrypt_User(const userid_t user_id, const std::string& Password) {
+	printf("Attempting to decrypt user\n");
+    uint8_t *auth_token;
+    uint32_t auth_token_len;
+    int ret;
+
+    struct stat st;
+    if (user_id > 9999) {
+		printf("user_id is too big\n");
+		return false;
+	}
+    std::string filename;
+    bool Default_Password = (Password == "!");
+    if (Get_Password_Type(user_id, filename) == 0 && !Default_Password) {
+		printf("Unknown password type\n");
+		return false;
+	}
+
+	int flags = android::os::IVold::STORAGE_FLAG_CE;
+
+	if (Default_Password) {
+		if (!fscrypt_unlock_user_key(user_id, 0, "!")) {
+			printf("unlock_user_key returned fail\n");
+			return false;
+		}
+		printf("Attempting to prepare user storage\n");
+		if (!fscrypt_prepare_user_storage("", user_id, 0, flags)) {
+			printf("failed to fscrypt_prepare_user_storage\n");
+			return false;
+		}
+		printf("User %i Decrypted Successfully!\n", user_id);
+		return true;
+	}
+	if (stat("/data/system_de/0/spblob", &st) == 0) {
+		printf("Using synthetic password method\n");
+		return Decrypt_User_Synth_Pass(user_id, Password);
+	}
+	// printf("password filename is '%s'\n", filename.c_str());
+	if (stat(filename.c_str(), &st) != 0) {
+		printf("error stat'ing key file: %s\n", strerror(errno));
+		return false;
+	}
+	std::string handle;
+    if (!android::base::ReadFileToString(filename, &handle)) {
+		printf("Failed to read '%s'\n", filename.c_str());
+		return false;
+	}
+    bool should_reenroll;
+	bool request_reenroll = false;
+	printf("fscrypt::gatekeeper::1\n");
+	android::sp<android::hardware::gatekeeper::V1_0::IGatekeeper> gk_device;
+	printf("fscrypt::gatekeeper::2\n");
+	gk_device = ::android::hardware::gatekeeper::V1_0::IGatekeeper::getService();
+	printf("fscrypt::gatekeeper::3\n");
+	if (gk_device == nullptr)
+		return false;
+	android::hardware::hidl_vec<uint8_t> curPwdHandle;
+	printf("fscrypt::gatekeeper::4\n");
+	curPwdHandle.setToExternal(const_cast<uint8_t *>((const uint8_t *)handle.c_str()), st.st_size);
+	printf("fscrypt::gatekeeper::5\n");
+	android::hardware::hidl_vec<uint8_t> enteredPwd;
+	printf("fscrypt::gatekeeper::6\n");
+	enteredPwd.setToExternal(const_cast<uint8_t *>((const uint8_t *)Password.c_str()), Password.size());
+
+	printf("fscrypt::gatekeeper::7\n");
+	android::hardware::Return<void> hwRet =
+		gk_device->verify(user_id, 0 /* challange */,
+						  curPwdHandle,
+						  enteredPwd,
+						  [&ret, &request_reenroll, &auth_token, &auth_token_len]
+							(const android::hardware::gatekeeper::V1_0::GatekeeperResponse &rsp) {
+								ret = static_cast<int>(rsp.code); // propagate errors
+								if (rsp.code >= android::hardware::gatekeeper::V1_0::GatekeeperStatusCode::STATUS_OK) {
+									auth_token = new uint8_t[rsp.data.size()];
+									auth_token_len = rsp.data.size();
+									memcpy(auth_token, rsp.data.data(), auth_token_len);
+									request_reenroll = (rsp.code == android::hardware::gatekeeper::V1_0::GatekeeperStatusCode::STATUS_REENROLL);
+									ret = 0; // all success states are reported as 0
+								} else if (rsp.code == android::hardware::gatekeeper::V1_0::GatekeeperStatusCode::ERROR_RETRY_TIMEOUT && rsp.timeout > 0) {
+									ret = rsp.timeout;
+								}
+							}
+						 );
+	if (!hwRet.isOk()) {
+		return false;
+	}
+
+	char token_hex[(auth_token_len*2)+1];
+	token_hex[(auth_token_len*2)] = 0;
+	uint32_t i;
+	for (i=0;i<auth_token_len;i++) {
+		sprintf(&token_hex[2*i], "%02X", auth_token[i]);
+	}
+	// The secret is "Android FBE credential hash" plus appended 0x00 to reach 128 bytes then append the user's password then feed that to sha512sum
+	std::string secret = HashPassword(Password);
+	if (!fscrypt_unlock_user_key(user_id, 0, secret)) {
+		printf("fscrypt_unlock_user_key returned fail\n");
+		return false;
+	}
+
+	printf("Attempting to prepare user storage\n");
+	if (!fscrypt_prepare_user_storage("", user_id, 0, flags)) {
+		printf("failed to fscrypt_prepare_user_storage\n");
+		return false;
+	}
+	printf("User %i Decrypted Successfully!\n", user_id);
+	return true;
+}
+}
diff --git a/Decrypt.h b/Decrypt.h
new file mode 100755
index 0000000..ff926dc
--- /dev/null
+++ b/Decrypt.h
@@ -0,0 +1,43 @@
+/*
+ * Copyright (C) 2015 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <stdbool.h>
+#include <sys/cdefs.h>
+
+#include <cutils/multiuser.h>
+
+#include <string>
+
+__BEGIN_DECLS
+
+// NOTE: keep in sync with StorageManager
+static constexpr int FLAG_STORAGE_DE = 1 << 0;
+static constexpr int FLAG_STORAGE_CE = 1 << 1;
+// For 9.0 Ext4CryptPie.cpp
+static constexpr int STORAGE_FLAG_DE = 1;
+static constexpr int STORAGE_FLAG_CE = 2;
+
+static constexpr int NAMESPACE_LOCKSETTINGS = 103;
+
+namespace android {
+namespace keystore {
+    void copySqliteDb();
+    int Get_Password_Type(const userid_t user_id, std::string& filename);
+    bool Decrypt_DE();
+    bool Decrypt_User(const userid_t user_id, const std::string& Password);
+}
+}
+__END_DECLS
diff --git a/FsCrypt.cpp b/FsCrypt.cpp
index 09dcf81..e6e575e 100644
--- a/FsCrypt.cpp
+++ b/FsCrypt.cpp
@@ -60,6 +60,7 @@
 #include <android-base/stringprintf.h>
 #include <android-base/strings.h>
 #include <android-base/unique_fd.h>
+#include "fscrypt-common.h"
 
 using android::base::Basename;
 using android::base::Realpath;
@@ -97,11 +98,12 @@ const std::string systemwide_volume_key_dir =
 // Some users are ephemeral, don't try to wipe their keys from disk
 std::set<userid_t> s_ephemeral_users;
 
+}  // namespace
+
 // Map user ids to encryption policies
 std::map<userid_t, EncryptionPolicy> s_de_policies;
 std::map<userid_t, EncryptionPolicy> s_ce_policies;
-
-}  // namespace
+std::string de_key_raw_ref;
 
 // Returns KeyGeneration suitable for key as described in EncryptionOptions
 static KeyGeneration makeGen(const EncryptionOptions& options) {
@@ -201,6 +203,7 @@ static bool read_and_fixate_user_ce_key(userid_t user_id,
     auto const paths = get_ce_key_paths(directory_path);
     for (auto const ce_key_path : paths) {
         LOG(DEBUG) << "Trying user CE key " << ce_key_path;
+        LOG(INFO) <<"fscrypt::read_and_fixate_user_ce_key::retrieveKey";
         if (retrieveKey(ce_key_path, auth, ce_key)) {
             LOG(DEBUG) << "Successfully retrieved key";
             fixate_user_ce_key(directory_path, ce_key_path, paths);
@@ -233,6 +236,12 @@ static bool IsEmmcStorage(const std::string& blk_device) {
 
 // Retrieve the options to use for encryption policies on the /data filesystem.
 static bool get_data_file_encryption_options(EncryptionOptions* options) {
+    if (fstab_default.empty()) {
+        if (!ReadDefaultFstab(&fstab_default)) {
+            PLOG(ERROR) << "Failed to open default fstab";
+            return false;
+        }
+    }
     auto entry = GetEntryForMountPoint(&fstab_default, DATA_MNT_POINT);
     if (entry == nullptr) {
         LOG(ERROR) << "No mount point entry for " << DATA_MNT_POINT;
@@ -307,7 +316,7 @@ static bool read_and_install_user_ce_key(userid_t user_id,
     EncryptionPolicy ce_policy;
     if (!install_storage_key(DATA_MNT_POINT, options, ce_key, &ce_policy)) return false;
     s_ce_policies[user_id] = ce_policy;
-    LOG(DEBUG) << "Installed ce key for user " << user_id;
+    LOG(INFO) << "Installed ce key for user " << user_id;
     return true;
 }
 
@@ -410,6 +419,7 @@ static bool load_all_de_keys() {
         userid_t user_id = std::stoi(entry->d_name);
         auto key_path = de_dir + "/" + entry->d_name;
         KeyBuffer de_key;
+        LOG(INFO) << "fscrypt::load_all_de_keys::retrieveKey";
         if (!retrieveKey(key_path, kEmptyAuthentication, &de_key)) return false;
         EncryptionPolicy de_policy;
         if (!install_storage_key(DATA_MNT_POINT, options, de_key, &de_policy)) return false;
@@ -418,7 +428,9 @@ static bool load_all_de_keys() {
             LOG(ERROR) << "DE policy for user" << user_id << " changed";
             return false;
         }
-        LOG(DEBUG) << "Installed de key for user " << user_id;
+        LOG(INFO) << "Installed de key for user " << user_id;
+        std::string user_prop = "twrp.user." + std::to_string(user_id) + ".decrypt";
+        property_set(user_prop.c_str(), "0");
     }
     // fscrypt:TODO: go through all DE directories, ensure that all user dirs have the
     // correct policy set on them, and that no rogue ones exist.
@@ -427,6 +439,7 @@ static bool load_all_de_keys() {
 
 // Attempt to reinstall CE keys for users that we think are unlocked.
 static bool try_reload_ce_keys() {
+    LOG(INFO) << "try_reload_ce_keys";
     for (const auto& it : s_ce_policies) {
         if (!android::vold::reloadKeyFromSessionKeyring(DATA_MNT_POINT, it.second)) {
             LOG(ERROR) << "Failed to load CE key from session keyring for user " << it.first;
@@ -459,6 +472,7 @@ bool fscrypt_initialize_systemwide_keys() {
     if (!android::vold::writeStringToFile(options_string, options_filename)) return false;
 
     std::string ref_filename = std::string(DATA_MNT_POINT) + fscrypt_key_ref;
+    de_key_raw_ref = device_policy.key_raw_ref;
     if (!android::vold::writeStringToFile(device_policy.key_raw_ref, ref_filename)) return false;
     LOG(INFO) << "Wrote system DE key reference to:" << ref_filename;
 
@@ -475,7 +489,7 @@ bool fscrypt_initialize_systemwide_keys() {
 }
 
 bool fscrypt_init_user0() {
-    LOG(DEBUG) << "fscrypt_init_user0";
+    LOG(INFO) << "fscrypt_init_user0";
     if (fscrypt_is_native()) {
         if (!prepare_dir(user_key_dir, 0700, AID_ROOT, AID_ROOT)) return false;
         if (!prepare_dir(user_key_dir + "/ce", 0700, AID_ROOT, AID_ROOT)) return false;
@@ -690,12 +704,12 @@ static bool fscrypt_rewrap_user_key(userid_t user_id, int serial,
     KeyBuffer ce_key;
     std::string ce_key_current_path = get_ce_key_current_path(directory_path);
     if (retrieveKey(ce_key_current_path, retrieve_auth, &ce_key)) {
-        LOG(DEBUG) << "Successfully retrieved key";
+        LOG(INFO) << "Successfully retrieved key";
         // TODO(147732812): Remove this once Locksettingservice is fixed.
         // Currently it calls fscrypt_clear_user_key_auth with a secret when lockscreen is
         // changed from swipe to none or vice-versa
     } else if (retrieveKey(ce_key_current_path, kEmptyAuthentication, &ce_key)) {
-        LOG(DEBUG) << "Successfully retrieved key with empty auth";
+        LOG(INFO) << "Successfully retrieved key with empty auth";
     } else {
         LOG(ERROR) << "Failed to retrieve key for user " << user_id;
         return false;
@@ -748,7 +762,7 @@ std::vector<int> fscrypt_get_unlocked_users() {
 
 // TODO: rename to 'install' for consistency, and take flags to know which keys to install
 bool fscrypt_unlock_user_key(userid_t user_id, int serial, const std::string& secret_hex) {
-    LOG(DEBUG) << "fscrypt_unlock_user_key " << user_id << " serial=" << serial;
+    LOG(INFO) << "fscrypt_unlock_user_key " << user_id << " serial=" << serial;
     if (fscrypt_is_native()) {
         if (s_ce_policies.count(user_id) != 0) {
             LOG(WARNING) << "Tried to unlock already-unlocked key for user " << user_id;
@@ -807,7 +821,7 @@ static bool prepare_subdirs(const std::string& action, const std::string& volume
 
 bool fscrypt_prepare_user_storage(const std::string& volume_uuid, userid_t user_id, int serial,
                                   int flags) {
-    LOG(DEBUG) << "fscrypt_prepare_user_storage for volume " << escape_empty(volume_uuid)
+    LOG(INFO) << "fscrypt_prepare_user_storage for volume " << escape_empty(volume_uuid)
                << ", user " << user_id << ", serial " << serial << ", flags " << flags;
 
     if (flags & android::os::IVold::STORAGE_FLAG_DE) {
@@ -850,7 +864,6 @@ bool fscrypt_prepare_user_storage(const std::string& volume_uuid, userid_t user_
             if (!EnsurePolicy(de_policy, user_de_path)) return false;
         }
     }
-
     if (flags & android::os::IVold::STORAGE_FLAG_CE) {
         // CE_n key
         auto system_ce_path = android::vold::BuildDataSystemCePath(user_id);
@@ -858,6 +871,7 @@ bool fscrypt_prepare_user_storage(const std::string& volume_uuid, userid_t user_
         auto vendor_ce_path = android::vold::BuildDataVendorCePath(user_id);
         auto media_ce_path = android::vold::BuildDataMediaCePath(volume_uuid, user_id);
         auto user_ce_path = android::vold::BuildDataUserCePath(volume_uuid, user_id);
+        LOG(INFO) << "fscrypt_prepare_user_storage";
 
         if (volume_uuid.empty()) {
             if (!prepare_dir(system_ce_path, 0770, AID_SYSTEM, AID_SYSTEM)) return false;
@@ -875,7 +889,6 @@ bool fscrypt_prepare_user_storage(const std::string& volume_uuid, userid_t user_
         }
 
         if (!prepare_dir(user_ce_path, 0771, AID_SYSTEM, AID_SYSTEM)) return false;
-
         if (fscrypt_is_native()) {
             EncryptionPolicy ce_policy;
             if (volume_uuid.empty()) {
@@ -1000,3 +1013,14 @@ bool fscrypt_destroy_volume_keys(const std::string& volume_uuid) {
     res &= destroy_volume_keys("/data/misc_de", volume_uuid);
     return res;
 }
+
+bool lookup_key_ref(const std::map<userid_t, android::fscrypt::EncryptionPolicy>& key_map, userid_t user_id,
+                           std::string* raw_ref) {
+    auto refi = key_map.find(user_id);
+    if (refi == key_map.end()) {
+        LOG(ERROR) << "Cannot find key for " << user_id;
+        return false;
+    }
+    *raw_ref = refi->second.key_raw_ref;
+    return true;
+}
\ No newline at end of file
diff --git a/FsCrypt.h b/FsCrypt.h
index 0517605..14a115a 100644
--- a/FsCrypt.h
+++ b/FsCrypt.h
@@ -40,3 +40,5 @@ bool fscrypt_destroy_user_storage(const std::string& volume_uuid, userid_t user_
 
 bool fscrypt_destroy_volume_keys(const std::string& volume_uuid);
 bool is_metadata_wrapped_key_supported();
+bool lookup_key_ref(const std::map<userid_t, android::fscrypt::EncryptionPolicy>& key_map, userid_t user_id,
+                           std::string* raw_ref);
diff --git a/HashPassword.cpp b/HashPassword.cpp
new file mode 100644
index 0000000..07ecb1f
--- /dev/null
+++ b/HashPassword.cpp
@@ -0,0 +1,117 @@
+/*
+ * Copyright (C) 2016 Team Win Recovery Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/*
+ * This computes the "secret" used by Android as one of the parameters
+ * to decrypt File Based Encryption. The secret is prefixed with
+ * "Android FBE credential hash" padded with 0s to 128 bytes then the
+ * user's password is appended to the end of the 128 bytes. This string
+ * is then hashed with sha512 and the sha512 value is then converted to
+ * hex with upper-case characters.
+ */
+
+#include <stdio.h>
+#include <string>
+#include <stdlib.h>
+#include <openssl/sha.h>
+#include <openssl/hmac.h>
+
+#include "HashPassword.h"
+
+#define PASS_PADDING_SIZE 128
+#define SHA512_HEX_SIZE SHA512_DIGEST_LENGTH * 2
+#define SHA256_HEX_SIZE SHA256_DIGEST_LENGTH * 2
+
+void* PersonalizedHashBinary(const char* prefix, const char* key, const size_t key_size) {
+	size_t size = PASS_PADDING_SIZE + key_size;
+	unsigned char* buffer = (unsigned char*)calloc(1, size);
+	if (!buffer) return NULL; // failed to malloc
+	memcpy((void*)buffer, (void*)prefix, strlen(prefix));
+	unsigned char* ptr = buffer + PASS_PADDING_SIZE;
+	memcpy((void*)ptr, key, key_size);
+	unsigned char hash[SHA512_DIGEST_LENGTH];
+	SHA512_CTX sha512;
+	SHA512_Init(&sha512);
+	SHA512_Update(&sha512, buffer, size);
+	SHA512_Final(hash, &sha512);
+	free(buffer);
+	void* ret = malloc(SHA512_DIGEST_LENGTH);
+	if (!ret) return NULL; // failed to malloc
+	memcpy(ret, (void*)&hash[0], SHA512_DIGEST_LENGTH);
+	return ret;
+}
+
+std::string PersonalizedHash(const char* prefix, const char* key, const size_t key_size) {
+	size_t size = PASS_PADDING_SIZE + key_size;
+	unsigned char* buffer = (unsigned char*)calloc(1, size);
+	if (!buffer) return ""; // failed to malloc
+	memcpy((void*)buffer, (void*)prefix, strlen(prefix));
+	unsigned char* ptr = buffer + PASS_PADDING_SIZE;
+	memcpy((void*)ptr, key, key_size);
+	unsigned char hash[SHA512_DIGEST_LENGTH];
+	SHA512_CTX sha512;
+	SHA512_Init(&sha512);
+	SHA512_Update(&sha512, buffer, size);
+	SHA512_Final(hash, &sha512);
+	int index = 0;
+	char hex_hash[SHA512_HEX_SIZE + 1];
+	for(index = 0; index < SHA512_DIGEST_LENGTH; index++)
+		sprintf(hex_hash + (index * 2), "%02X", hash[index]);
+	hex_hash[128] = 0;
+	std::string ret = hex_hash;
+	free(buffer);
+	return ret;
+}
+
+std::string PersonalizedHash(const char* prefix, const std::string& Password) {
+	return PersonalizedHash(prefix, Password.c_str(), Password.size());
+}
+
+std::string PersonalizedHashSP800(const char* label, const char* context, const char* key, const size_t key_size) {
+	HMAC_CTX ctx;
+	HMAC_CTX_init(&ctx);
+	HMAC_Init_ex(&ctx, key, key_size, EVP_sha256(), NULL);
+	unsigned int counter = 1;
+	endianswap(&counter);
+	HMAC_Update(&ctx, (const unsigned char*)&counter, 4);
+	HMAC_Update(&ctx, (const unsigned char*)label, strlen(label));
+	const unsigned char divider = 0;
+	HMAC_Update(&ctx, &divider, 1);
+	HMAC_Update(&ctx, (const unsigned char*)context, strlen(context));
+	unsigned int contextDisambiguation = strlen(context) * 8;
+	endianswap(&contextDisambiguation);
+	HMAC_Update(&ctx, (const unsigned char*)&contextDisambiguation, 4);
+	unsigned int finalValue = 256;
+	endianswap(&finalValue);
+	HMAC_Update(&ctx, (const unsigned char*)&finalValue, 4);
+
+	unsigned char output[SHA256_DIGEST_LENGTH];
+	unsigned int out_size = 0;
+	HMAC_Final(&ctx, output, &out_size);
+
+	int index = 0;
+	char hex_hash[SHA256_HEX_SIZE + 1];
+	for(index = 0; index < SHA256_DIGEST_LENGTH; index++)
+		sprintf(hex_hash + (index * 2), "%02x", output[index]);
+	hex_hash[SHA256_HEX_SIZE] = 0;
+	std::string ret = hex_hash;
+	return ret;
+}
+
+std::string HashPassword(const std::string& Password) {
+	const char* prefix = FBE_PERSONALIZATION;
+	return PersonalizedHash(prefix, Password);
+}
diff --git a/HashPassword.h b/HashPassword.h
new file mode 100644
index 0000000..73880b1
--- /dev/null
+++ b/HashPassword.h
@@ -0,0 +1,44 @@
+/*
+ * Copyright (C) 2016 Team Win Recovery Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef __HASH_PASSWORD_H
+#define __HASH_PASSWORD_H
+
+#include <string>
+
+#define FBE_PERSONALIZATION "Android FBE credential hash"
+#define PERSONALISATION_WEAVER_KEY "weaver-key"
+#define PERSONALISATION_WEAVER_PASSWORD "weaver-pwd"
+#define PERSONALISATION_APPLICATION_ID "application-id"
+#define PERSONALIZATION_FBE_KEY "fbe-key"
+#define PERSONALIZATION_USER_GK_AUTH "user-gk-authentication"
+#define PERSONALISATION_SECDISCARDABLE "secdiscardable-transform"
+#define PERSONALISATION_CONTEXT "android-synthetic-password-personalization-context"
+
+void* PersonalizedHashBinary(const char* prefix, const char* key, const size_t key_size);
+
+std::string PersonalizedHash(const char* prefix, const char* key, const size_t key_size);
+std::string PersonalizedHash(const char* prefix, const std::string& Password);
+std::string PersonalizedHashSP800(const char* label, const char* context, const char* key, const size_t key_size);
+std::string HashPassword(const std::string& Password);
+
+template <class T>
+void endianswap(T *objp) {
+	unsigned char *memp = reinterpret_cast<unsigned char*>(objp);
+	std::reverse(memp, memp + sizeof(T));
+}
+
+#endif
diff --git a/KeyStorage.cpp b/KeyStorage.cpp
index c83c1eb..dadc37e 100644
--- a/KeyStorage.cpp
+++ b/KeyStorage.cpp
@@ -149,7 +149,7 @@ static bool generateKeyStorageKey(Keymaster& keymaster, const std::string& appId
                                 .GcmModeMinMacLen(GCM_MAC_BYTES * 8)
                                 .Authorization(km::TAG_APPLICATION_ID, appId)
                                 .Authorization(km::TAG_NO_AUTH_REQUIRED);
-    LOG(DEBUG) << "Generating \"key storage\" key";
+    LOG(INFO) << "Generating \"key storage\" key";
     return generateKeymasterKey(keymaster, paramBuilder, key);
 }
 
@@ -229,65 +229,65 @@ static std::vector<std::string> key_dirs_to_commit;
 
 // Replaces |dir|/keymaster_key_blob with |dir|/keymaster_key_blob_upgraded and
 // deletes the old key from Keymaster.
-static bool CommitUpgradedKey(Keymaster& keymaster, const std::string& dir) {
-    auto blob_file = dir + "/" + kFn_keymaster_key_blob;
-    auto upgraded_blob_file = dir + "/" + kFn_keymaster_key_blob_upgraded;
-
-    std::string blob;
-    if (!readFileToString(blob_file, &blob)) return false;
-
-    if (rename(upgraded_blob_file.c_str(), blob_file.c_str()) != 0) {
-        PLOG(ERROR) << "Failed to rename " << upgraded_blob_file << " to " << blob_file;
-        return false;
-    }
-    // Ensure that the rename is persisted before deleting the Keymaster key.
-    if (!FsyncDirectory(dir)) return false;
-
-    if (!keymaster || !keymaster.deleteKey(blob)) {
-        LOG(WARNING) << "Failed to delete old key " << blob_file
-                     << " from Keymaster; continuing anyway";
-        // Continue on, but the space in Keymaster used by the old key won't be freed.
-    }
-    return true;
-}
-
-static void DeferredCommitKeys() {
-    android::base::WaitForProperty("vold.checkpoint_committed", "1");
-    LOG(INFO) << "Committing upgraded keys";
-    Keymaster keymaster;
-    if (!keymaster) {
-        LOG(ERROR) << "Failed to open Keymaster; old keys won't be deleted from Keymaster";
+// static bool CommitUpgradedKey(Keymaster& keymaster, const std::string& dir) {
+//     auto blob_file = dir + "/" + kFn_keymaster_key_blob;
+//     auto upgraded_blob_file = dir + "/" + kFn_keymaster_key_blob_upgraded;
+
+//     std::string blob;
+//     if (!readFileToString(blob_file, &blob)) return false;
+
+//     if (rename(upgraded_blob_file.c_str(), blob_file.c_str()) != 0) {
+//         PLOG(ERROR) << "Failed to rename " << upgraded_blob_file << " to " << blob_file;
+//         return false;
+//     }
+//     // Ensure that the rename is persisted before deleting the Keymaster key.
+//     if (!FsyncDirectory(dir)) return false;
+
+//     if (!keymaster || !keymaster.deleteKey(blob)) {
+//         LOG(WARNING) << "Failed to delete old key " << blob_file
+//                      << " from Keymaster; continuing anyway";
+//         // Continue on, but the space in Keymaster used by the old key won't be freed.
+//     }
+//     return true;
+// }
+
+// static void DeferredCommitKeys() {
+//     android::base::WaitForProperty("vold.checkpoint_committed", "1");
+//     LOG(INFO) << "Committing upgraded keys";
+//     Keymaster keymaster;
+//     if (!keymaster) {
+//         LOG(ERROR) << "Failed to open Keymaster; old keys won't be deleted from Keymaster";
         // Continue on, but the space in Keymaster used by the old keys won't be freed.
-    }
-    std::lock_guard<std::mutex> lock(key_upgrade_lock);
-    for (auto& dir : key_dirs_to_commit) {
-        LOG(INFO) << "Committing upgraded key " << dir;
-        CommitUpgradedKey(keymaster, dir);
-    }
-    key_dirs_to_commit.clear();
-}
+//     }
+//     std::lock_guard<std::mutex> lock(key_upgrade_lock);
+//     for (auto& dir : key_dirs_to_commit) {
+//         LOG(INFO) << "Committing upgraded key " << dir;
+//         CommitUpgradedKey(keymaster, dir);
+//     }
+//     key_dirs_to_commit.clear();
+// }
 
 // Returns true if the Keymaster key in |dir| has already been upgraded and is
 // pending being committed.  Assumes that key_upgrade_lock is held.
-static bool IsKeyCommitPending(const std::string& dir) {
-    for (const auto& dir_to_commit : key_dirs_to_commit) {
-        if (IsSameFile(dir, dir_to_commit)) return true;
-    }
-    return false;
-}
+// static bool IsKeyCommitPending(const std::string& dir) {
+//     for (const auto& dir_to_commit : key_dirs_to_commit) {
+//         if (IsSameFile(dir, dir_to_commit)) return true;
+//     }
+//     return false;
+// }
 
 // Schedules the upgraded Keymaster key in |dir| to be committed later.
 // Assumes that key_upgrade_lock is held.
-static void ScheduleKeyCommit(const std::string& dir) {
-    if (key_dirs_to_commit.empty()) std::thread(DeferredCommitKeys).detach();
-    key_dirs_to_commit.push_back(dir);
-}
+// static void ScheduleKeyCommit(const std::string& dir) {
+//     if (key_dirs_to_commit.empty()) std::thread(DeferredCommitKeys).detach();
+//     key_dirs_to_commit.push_back(dir);
+// }
 
 static void CancelPendingKeyCommit(const std::string& dir) {
     std::lock_guard<std::mutex> lock(key_upgrade_lock);
     for (auto it = key_dirs_to_commit.begin(); it != key_dirs_to_commit.end(); it++) {
         if (IsSameFile(*it, dir)) {
-            LOG(DEBUG) << "Cancelling pending commit of upgraded key " << dir
+            LOG(INFO) << "Cancelling pending commit of upgraded key " << dir
                        << " because it is being destroyed";
             key_dirs_to_commit.erase(it);
             break;
@@ -316,23 +316,23 @@ static bool RenameKeyDir(const std::string& old_name, const std::string& new_nam
 // Deletes a leftover upgraded key, if present.  An upgraded key can be left
 // over if an update failed, or if we rebooted before committing the key in a
 // freak accident.  Either way, we can re-upgrade the key if we need to.
-static void DeleteUpgradedKey(Keymaster& keymaster, const std::string& path) {
-    if (pathExists(path)) {
-        LOG(DEBUG) << "Deleting leftover upgraded key " << path;
-        std::string blob;
-        if (!android::base::ReadFileToString(path, &blob)) {
-            LOG(WARNING) << "Failed to read leftover upgraded key " << path
-                         << "; continuing anyway";
-        } else if (!keymaster.deleteKey(blob)) {
-            LOG(WARNING) << "Failed to delete leftover upgraded key " << path
-                         << " from Keymaster; continuing anyway";
-        }
-        if (unlink(path.c_str()) != 0) {
-            LOG(WARNING) << "Failed to unlink leftover upgraded key " << path
-                         << "; continuing anyway";
-        }
-    }
-}
+// static void DeleteUpgradedKey(Keymaster& keymaster, const std::string& path) {
+//     if (pathExists(path)) {
+//         LOG(INFO) << "Deleting leftover upgraded key " << path;
+//         std::string blob;
+//         if (!android::base::ReadFileToString(path, &blob)) {
+//             LOG(WARNING) << "Failed to read leftover upgraded key " << path
+//                          << "; continuing anyway";
+//         } else if (!keymaster.deleteKey(blob)) {
+//             LOG(WARNING) << "Failed to delete leftover upgraded key " << path
+//                          << " from Keymaster; continuing anyway";
+//         }
+//         if (unlink(path.c_str()) != 0) {
+//             LOG(WARNING) << "Failed to unlink leftover upgraded key " << path
+//                          << "; continuing anyway";
+//         }
+//     }
+// }
 
 // Begins a Keymaster operation using the key stored in |dir|.
 static KeymasterOperation BeginKeymasterOp(Keymaster& keymaster, const std::string& dir,
@@ -343,44 +343,52 @@ static KeymasterOperation BeginKeymasterOp(Keymaster& keymaster, const std::stri
     inParams.append(opParams.begin(), opParams.end());
 
     auto blob_file = dir + "/" + kFn_keymaster_key_blob;
-    auto upgraded_blob_file = dir + "/" + kFn_keymaster_key_blob_upgraded;
+    PLOG(INFO) << "reading blob_file: " << blob_file;
+    std::string blob_dir(kFn_keymaster_key_blob);
+    std::string temp_dir = "/tmp/" + blob_dir + "/";
+    if (TEMP_FAILURE_RETRY(mkdir(temp_dir.c_str(), 0700)) == -1) {
+        PLOG(ERROR) << "key mkdir " << temp_dir;
+    }
 
+    auto upgraded_blob_file = temp_dir + kFn_keymaster_key_blob;
+    // auto upgraded_blob_file = dir + "/" + kFn_keymaster_key_blob_upgraded;
     std::lock_guard<std::mutex> lock(key_upgrade_lock);
 
     std::string blob;
-    bool already_upgraded = IsKeyCommitPending(dir);
-    if (already_upgraded) {
-        LOG(DEBUG)
-                << blob_file
-                << " was already upgraded and is waiting to be committed; using the upgraded blob";
-        if (!readFileToString(upgraded_blob_file, &blob)) return KeymasterOperation();
-    } else {
-        DeleteUpgradedKey(keymaster, upgraded_blob_file);
-        if (!readFileToString(blob_file, &blob)) return KeymasterOperation();
-    }
+    // bool already_upgraded = IsKeyCommitPending(dir);
+    // if (already_upgraded) {
+    //     LOG(INFO)
+    //             << blob_file
+    //             << " was already upgraded and is waiting to be committed; using the upgraded blob";
+    //     if (!readFileToString(upgraded_blob_file, &blob)) return KeymasterOperation();
+    // } else {
+        // DeleteUpgradedKey(keymaster, upgraded_blob_file);
+    if (!readFileToString(blob_file, &blob)) return KeymasterOperation();
+    // }
 
     auto opHandle = keymaster.begin(blob, inParams, outParams);
     if (!opHandle) return opHandle;
 
     // If key blob wasn't upgraded, nothing left to do.
-    if (!opHandle.getUpgradedBlob()) return opHandle;
+    // if (!opHandle.getUpgradedBlob()) return opHandle;
 
-    if (already_upgraded) {
-        LOG(ERROR) << "Unexpected case; already-upgraded key " << upgraded_blob_file
-                   << " still requires upgrade";
-        return KeymasterOperation();
-    }
+    // if (already_upgraded) {
+    //     LOG(ERROR) << "Unexpected case; already-upgraded key " << upgraded_blob_file
+    //                << " still requires upgrade";
+    //     return KeymasterOperation();
+    // }
     LOG(INFO) << "Upgrading key: " << blob_file;
+    
     if (!writeStringToFile(*opHandle.getUpgradedBlob(), upgraded_blob_file))
         return KeymasterOperation();
-    if (cp_needsCheckpoint()) {
-        LOG(INFO) << "Wrote upgraded key to " << upgraded_blob_file
-                  << "; delaying commit due to checkpoint";
-        ScheduleKeyCommit(dir);
-    } else {
-        if (!CommitUpgradedKey(keymaster, dir)) return KeymasterOperation();
-        LOG(INFO) << "Key upgraded: " << blob_file;
-    }
+    // if (cp_needsCheckpoint()) {
+    //     LOG(INFO) << "Wrote upgraded key to " << upgraded_blob_file
+    //               << "; delaying commit due to checkpoint";
+    //     ScheduleKeyCommit(dir);
+    // } else {
+    //     if (!CommitUpgradedKey(keymaster, dir)) return KeymasterOperation();
+    //     LOG(INFO) << "Key upgraded: " << blob_file;
+    // }
     return opHandle;
 }
 
@@ -614,7 +622,7 @@ bool storeKeyAtomically(const std::string& key_path, const std::string& tmp_path
         return false;
     }
     if (pathExists(tmp_path)) {
-        LOG(DEBUG) << "Already exists, destroying: " << tmp_path;
+        LOG(INFO) << "Already exists, destroying: " << tmp_path;
         destroyKey(tmp_path);  // May be partially created so ignore errors
     }
     if (!storeKey(tmp_path, auth, key)) return false;
@@ -624,11 +632,12 @@ bool storeKeyAtomically(const std::string& key_path, const std::string& tmp_path
         return false;
     }
     if (!FsyncParentDirectory(key_path)) return false;
-    LOG(DEBUG) << "Created key: " << key_path;
+    LOG(INFO) << "Created key: " << key_path;
     return true;
 }
 
 bool retrieveKey(const std::string& dir, const KeyAuthentication& auth, KeyBuffer* key) {
+    LOG(INFO) << "Retrieving key from keymaster";
     std::string version;
     if (!readFileToString(dir + "/" + kFn_version, &version)) return false;
     if (version != kCurrentVersion) {
@@ -660,7 +669,7 @@ static bool DeleteKeymasterKey(const std::string& blob_file) {
     if (!readFileToString(blob_file, &blob)) return false;
     Keymaster keymaster;
     if (!keymaster) return false;
-    LOG(DEBUG) << "Deleting key " << blob_file << " from Keymaster";
+    LOG(INFO) << "Deleting key " << blob_file << " from Keymaster";
     if (!keymaster.deleteKey(blob)) return false;
     return true;
 }
diff --git a/KeyStorage.h b/KeyStorage.h
index e318959..e379c0c 100644
--- a/KeyStorage.h
+++ b/KeyStorage.h
@@ -56,6 +56,9 @@ bool storeKeyAtomically(const std::string& key_path, const std::string& tmp_path
                         const KeyAuthentication& auth, const KeyBuffer& key);
 
 // Retrieve the key from the named directory.
+//
+// If the key is wrapped by a Keymaster key that requires an upgrade, then that
+// Keymaster key is upgraded.  
 bool retrieveKey(const std::string& dir, const KeyAuthentication& auth, KeyBuffer* key);
 
 // Securely destroy the key stored in the named directory and delete the directory.
diff --git a/KeyUtil.cpp b/KeyUtil.cpp
index 2074b18..9273564 100644
--- a/KeyUtil.cpp
+++ b/KeyUtil.cpp
@@ -57,10 +57,10 @@ bool generateStorageKey(const KeyGeneration& gen, KeyBuffer* key) {
             LOG(ERROR) << "Cannot generate a wrapped key " << gen.keysize << " bytes long";
             return false;
         }
-        LOG(DEBUG) << "Generating wrapped storage key";
+        LOG(INFO) << "Generating wrapped storage key";
         return generateWrappedStorageKey(key);
     } else {
-        LOG(DEBUG) << "Generating standard storage key";
+        LOG(INFO) << "Generating standard storage key";
         return randomKey(gen.keysize, key);
     }
 }
@@ -87,7 +87,7 @@ static bool isFsKeyringSupportedImpl() {
     if (errno != EFAULT) {
         PLOG(WARNING) << "Unexpected error from FS_IOC_ADD_ENCRYPTION_KEY";
     }
-    LOG(DEBUG) << "Detected support for FS_IOC_ADD_ENCRYPTION_KEY";
+    LOG(INFO) << "Detected support for FS_IOC_ADD_ENCRYPTION_KEY";
     android::base::SetProperty("ro.crypto.uses_fs_ioc_add_encryption_key", "true");
     return true;
 }
@@ -172,7 +172,7 @@ static bool installKeyLegacy(const KeyBuffer& key, const std::string& raw_ref) {
             PLOG(ERROR) << "Failed to insert key into keyring " << device_keyring;
             return false;
         }
-        LOG(DEBUG) << "Added key " << key_id << " (" << ref << ") to keyring " << device_keyring
+        LOG(INFO) << "Added key " << key_id << " (" << ref << ") to keyring " << device_keyring
                    << " in process " << getpid();
     }
     return true;
@@ -200,7 +200,7 @@ static bool installProvisioningKey(const KeyBuffer& key, const std::string& ref,
                     << " into session keyring";
         return false;
     }
-    LOG(DEBUG) << "Added fscrypt-provisioning key for " << ref << " to session keyring";
+    LOG(INFO) << "Added fscrypt-provisioning key for " << ref << " to session keyring";
     return true;
 }
 
@@ -312,7 +312,7 @@ bool installKey(const std::string& mountpoint, const EncryptionOptions& options,
                 std::string((char*)arg->key_spec.u.identifier, FSCRYPT_KEY_IDENTIFIER_SIZE);
     }
     std::string ref = keyrefstring(policy->key_raw_ref);
-    LOG(DEBUG) << "Installed fscrypt key with ref " << ref << " to " << mountpoint;
+    LOG(INFO) << "Installed fscrypt key with ref " << ref << " to " << mountpoint;
 
     if (!installProvisioningKey(key, ref, arg->key_spec)) return false;
     return true;
@@ -335,7 +335,7 @@ static bool evictKeyLegacy(const std::string& raw_ref) {
             PLOG(ERROR) << "Failed to unlink key with serial " << key_serial << " ref " << ref;
             success = false;
         } else {
-            LOG(DEBUG) << "Unlinked key with serial " << key_serial << " ref " << ref;
+            LOG(INFO) << "Unlinked key with serial " << key_serial << " ref " << ref;
         }
     }
     return success;
@@ -386,7 +386,7 @@ bool evictKey(const std::string& mountpoint, const EncryptionPolicy& policy) {
         return false;
     }
 
-    LOG(DEBUG) << "Evicted fscrypt key with ref " << ref << " from " << mountpoint;
+    LOG(INFO) << "Evicted fscrypt key with ref " << ref << " from " << mountpoint;
     if (arg.removal_status_flags & FSCRYPT_KEY_REMOVAL_STATUS_FLAG_OTHER_USERS) {
         // Should never happen because keys are only added/removed as root.
         LOG(ERROR) << "Unexpected case: key with ref " << ref << " is still added by other users!";
@@ -403,7 +403,7 @@ bool retrieveOrGenerateKey(const std::string& key_path, const std::string& tmp_p
                            const KeyAuthentication& key_authentication, const KeyGeneration& gen,
                            KeyBuffer* key) {
     if (pathExists(key_path)) {
-        LOG(DEBUG) << "Key exists, using: " << key_path;
+        LOG(INFO) << "Key exists, using: " << key_path;
         if (!retrieveKey(key_path, key_authentication, key)) return false;
     } else {
         if (!gen.allow_gen) {
@@ -431,7 +431,7 @@ bool reloadKeyFromSessionKeyring(const std::string& mountpoint, const Encryption
         return false;
     }
 
-    LOG(DEBUG) << "Installing fscrypt-provisioning key for " << ref << " back into " << mountpoint
+    LOG(INFO) << "Installing fscrypt-provisioning key for " << ref << " back into " << mountpoint
                << " fs-keyring";
 
     struct fscrypt_add_key_arg arg;
diff --git a/Keymaster.cpp b/Keymaster.cpp
index 2314550..5aac9ba 100644
--- a/Keymaster.cpp
+++ b/Keymaster.cpp
@@ -199,7 +199,7 @@ KeymasterOperation Keymaster::begin(const std::string& key, const km::Authorizat
             std::optional<std::vector<uint8_t>>(std::vector<uint8_t>(key.begin(), key.end()));
 
     ks2::CreateOperationResponse cor;
-    auto rc = securityLevel->createOperation(keyDesc, inParams.vector_data(), true, &cor);
+    auto rc = securityLevel->createOperation(keyDesc, inParams.vector_data(), false, &cor);
     if (logKeystore2ExceptionIfPresent(rc, "createOperation")) {
         if (rc.getExceptionCode() == EX_SERVICE_SPECIFIC)
             return KeymasterOperation((km::ErrorCode)rc.getServiceSpecificError());
diff --git a/KeystoreInfo.cpp b/KeystoreInfo.cpp
new file mode 100755
index 0000000..9b13387
--- /dev/null
+++ b/KeystoreInfo.cpp
@@ -0,0 +1,79 @@
+/*
+		Copyright 2013 to 2022 TeamWin
+		TWRP is free software: you can redistribute it and/or modify
+		it under the terms of the GNU General Public License as published by
+		the Free Software Foundation, either version 3 of the License, or
+		(at your option) any later version.
+
+		TWRP is distributed in the hope that it will be useful,
+		but WITHOUT ANY WARRANTY; without even the implied warranty of
+		MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+		GNU General Public License for more details.
+
+		You should have received a copy of the GNU General Public License
+		along with TWRP.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+#include <string.h>
+#include <fcntl.h>
+#include <errno.h>
+#include <ctype.h>
+#include <string>
+#include <sstream>
+#include <algorithm>
+#include <string>
+#include <sqlite3.h>
+#include "KeystoreInfo.hpp"
+
+std::string KeystoreInfo::uint2hex(int64_t num) {
+	uint64_t temp = num;
+	std::string s = "";
+	while (temp) {
+		int a = temp % 16;
+		if (a <= 9)
+			s += (48 + a);
+		else
+			s += (87 + a);
+		temp = temp / 16;
+	}
+	std::reverse(s.begin(), s.end());
+	return s;
+}
+
+std::string KeystoreInfo::getHandle(const userid_t user_id) {
+	int rc = 0;
+   	sqlite3 *db;
+	sqlite3_stmt *stmt;
+	char *err_msg = 0;
+  	
+	rc = sqlite3_open("/data/system/locksettings.db", &db);
+	if (rc) {
+		fprintf(stderr, "Can't open database: %s\n", sqlite3_errmsg(db));
+		return "";
+	}
+	std::string sql = "SELECT * FROM locksettings WHERE name = 'sp-handle' AND user = " + std::to_string(user_id);
+	rc = sqlite3_prepare_v2(db, sql.c_str(), -1, &stmt, NULL);
+	if (rc != SQLITE_OK)
+		return "";
+	int64_t value = 0;
+	while ((rc = sqlite3_step(stmt)) == SQLITE_ROW) {
+		value = sqlite3_column_int64(stmt, 3);
+	}
+	if (rc != SQLITE_DONE) {
+		fprintf(stderr, "error: %s\n", sqlite3_errmsg(db));
+		return "";
+	}
+	sqlite3_finalize(stmt);
+	sqlite3_close(db);
+	return uint2hex(value);
+}
+
+std::string KeystoreInfo::getAlias(std::string handle) {
+	std::string alias(SYNTHETIC_PASSWORD_KEY_PREFIX);
+	alias = alias + handle;
+	return alias;
+}
diff --git a/KeystoreInfo.hpp b/KeystoreInfo.hpp
new file mode 100755
index 0000000..a6a5850
--- /dev/null
+++ b/KeystoreInfo.hpp
@@ -0,0 +1,32 @@
+/*
+		TWRP is free software: you can redistribute it and/or modify
+		it under the terms of the GNU General Public License as published by
+		the Free Software Foundation, either version 3 of the License, or
+		(at your option) any later version.
+
+		TWRP is distributed in the hope that it will be useful,
+		but WITHOUT ANY WARRANTY; without even the implied warranty of
+		MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+		GNU General Public License for more details.
+
+		You should have received a copy of the GNU General Public License
+		along with TWRP.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#include <string>
+#include <cutils/multiuser.h>
+
+#ifndef __KEYSTOREINFO_H
+#define __KEYSTOREINFO_H
+
+#define SYNTHETIC_PASSWORD_KEY_PREFIX "synthetic_password_"
+class KeystoreInfo {
+public:
+std::string getHandle(const userid_t user_id);
+std::string getAlias(std::string handle);
+
+private:
+std::string uint2hex(int64_t num);
+};
+
+#endif //__KEYSTOREINFO_H
diff --git a/MetadataCrypt.cpp b/MetadataCrypt.cpp
index e68e1ef..3e89063 100644
--- a/MetadataCrypt.cpp
+++ b/MetadataCrypt.cpp
@@ -88,6 +88,12 @@ static bool mount_via_fs_mgr(const char* mount_point, const char* blk_device) {
         PLOG(ERROR) << "Failed to setexeccon";
         return false;
     }
+    if (fstab_default.empty()) {
+        if (!ReadDefaultFstab(&fstab_default)) {
+            PLOG(ERROR) << "Failed to open default fstab";
+            return false;
+        }
+    }
     auto mount_rc = fs_mgr_do_mount(&fstab_default, const_cast<char*>(mount_point),
                                     const_cast<char*>(blk_device), nullptr,
                                     android::vold::cp_needsCheckpoint(), true);
@@ -99,7 +105,7 @@ static bool mount_via_fs_mgr(const char* mount_point, const char* blk_device) {
         LOG(ERROR) << "fs_mgr_do_mount failed with rc " << mount_rc;
         return false;
     }
-    LOG(DEBUG) << "Mounted " << mount_point;
+    LOG(INFO) << "Mounted " << mount_point;
     return true;
 }
 
@@ -111,7 +117,7 @@ static bool read_key(const std::string& metadata_key_dir, const KeyGeneration& g
     }
     std::string sKey;
     auto dir = metadata_key_dir + "/key";
-    LOG(DEBUG) << "metadata_key_dir/key: " << dir;
+    LOG(INFO) << "metadata_key_dir/key: " << dir;
     if (!MkdirsSync(dir, 0700)) return false;
     if (!pathExists(dir)) {
         auto delete_all = android::base::GetBoolProperty(
@@ -120,7 +126,7 @@ static bool read_key(const std::string& metadata_key_dir, const KeyGeneration& g
             LOG(INFO) << "Metadata key does not exist, calling deleteAllKeys";
             Keymaster::deleteAllKeys();
         } else {
-            LOG(DEBUG) << "Metadata key does not exist but "
+            LOG(INFO) << "Metadata key does not exist but "
                           "ro.crypto.metadata_init_delete_all_keys.enabled is false";
         }
     }
@@ -215,15 +221,22 @@ static bool parse_options(const std::string& options_string, CryptoOptions* opti
 bool fscrypt_mount_metadata_encrypted(const std::string& blk_device, const std::string& mount_point,
                                       bool needs_encrypt, bool should_format,
                                       const std::string& fs_type) {
-    LOG(DEBUG) << "fscrypt_mount_metadata_encrypted: " << mount_point
+    LOG(INFO) << "fscrypt_mount_metadata_encrypted: " << mount_point
                << " encrypt: " << needs_encrypt << " format: " << should_format << " with "
                << fs_type;
     auto encrypted_state = android::base::GetProperty("ro.crypto.state", "");
     if (encrypted_state != "" && encrypted_state != "encrypted") {
-        LOG(DEBUG) << "fscrypt_enable_crypto got unexpected starting state: " << encrypted_state;
+        LOG(INFO) << "fscrypt_enable_crypto got unexpected starting state: " << encrypted_state;
         return false;
     }
 
+    if (fstab_default.empty()) {
+        if (!ReadDefaultFstab(&fstab_default)) {
+            PLOG(ERROR) << "Failed to open default fstab";
+            return false;
+        }
+    }
+
     auto data_rec = GetEntryForMountPoint(&fstab_default, mount_point);
     if (!data_rec) {
         LOG(ERROR) << "Failed to get data_rec for " << mount_point;
@@ -278,15 +291,16 @@ bool fscrypt_mount_metadata_encrypted(const std::string& blk_device, const std::
                 LOG(ERROR) << "Unknown filesystem type: " << fs_type;
                 return false;
             }
-            LOG(DEBUG) << "Format (err=" << error << ") " << crypto_blkdev << " on " << mount_point;
+            LOG(INFO) << "Format (err=" << error << ") " << crypto_blkdev << " on " << mount_point;
             if (error != 0) return false;
         } else {
             if (!encrypt_inplace(crypto_blkdev, blk_device, nr_sec, false)) return false;
         }
     }
 
-    LOG(DEBUG) << "Mounting metadata-encrypted filesystem:" << mount_point;
+    LOG(INFO) << "Mounting metadata-encrypted filesystem:" << mount_point;
     mount_via_fs_mgr(mount_point.c_str(), crypto_blkdev.c_str());
+    android::base::SetProperty("ro.crypto.fs_crypto_blkdev", crypto_blkdev);
 
     // Record that there's at least one fstab entry with metadata encryption
     if (!android::base::SetProperty("ro.crypto.metadata.enabled", "true")) {
@@ -309,7 +323,7 @@ bool defaultkey_volume_keygen(KeyGeneration* gen) {
 
 bool defaultkey_setup_ext_volume(const std::string& label, const std::string& blk_device,
                                  const KeyBuffer& key, std::string* out_crypto_blkdev) {
-    LOG(DEBUG) << "defaultkey_setup_ext_volume: " << label << " " << blk_device;
+    LOG(INFO) << "defaultkey_setup_ext_volume: " << label << " " << blk_device;
 
     CryptoOptions options;
     if (!get_volume_options(&options)) return false;
@@ -318,17 +332,23 @@ bool defaultkey_setup_ext_volume(const std::string& label, const std::string& bl
 }
 
 bool destroy_dsu_metadata_key(const std::string& dsu_slot) {
-    LOG(DEBUG) << "destroy_dsu_metadata_key: " << dsu_slot;
+    LOG(INFO) << "destroy_dsu_metadata_key: " << dsu_slot;
 
     const auto dsu_metadata_key_dir = android::gsi::GetDsuMetadataKeyDir(dsu_slot);
     if (!pathExists(dsu_metadata_key_dir)) {
-        LOG(DEBUG) << "DSU metadata_key_dir doesn't exist, nothing to remove: "
+        LOG(INFO) << "DSU metadata_key_dir doesn't exist, nothing to remove: "
                    << dsu_metadata_key_dir;
         return true;
     }
 
     // Ensure that the DSU key directory is different from the host OS'.
     // Under normal circumstances, this should never happen, but handle it just in case.
+    if (fstab_default.empty()) {
+        if (!ReadDefaultFstab(&fstab_default)) {
+            PLOG(ERROR) << "Failed to open default fstab";
+            return false;
+        }
+    }
     if (auto data_rec = GetEntryForMountPoint(&fstab_default, "/data")) {
         if (dsu_metadata_key_dir == data_rec->metadata_key_dir) {
             LOG(ERROR) << "DSU metadata_key_dir is same as host OS: " << dsu_metadata_key_dir;
@@ -340,7 +360,7 @@ bool destroy_dsu_metadata_key(const std::string& dsu_slot) {
     for (auto suffix : {"/key", "/tmp"}) {
         const auto key_path = dsu_metadata_key_dir + suffix;
         if (pathExists(key_path)) {
-            LOG(DEBUG) << "Destroy key: " << key_path;
+            LOG(INFO) << "Destroy key: " << key_path;
             if (!android::vold::destroyKey(key_path)) {
                 LOG(ERROR) << "Failed to destroyKey(): " << key_path;
                 ok = false;
@@ -351,7 +371,7 @@ bool destroy_dsu_metadata_key(const std::string& dsu_slot) {
         return false;
     }
 
-    LOG(DEBUG) << "Remove DSU metadata_key_dir: " << dsu_metadata_key_dir;
+    LOG(INFO) << "Remove DSU metadata_key_dir: " << dsu_metadata_key_dir;
     // DeleteDirContentsAndDir() already logged any error, so don't log repeatedly.
     return android::vold::DeleteDirContentsAndDir(dsu_metadata_key_dir) == android::OK;
 }
diff --git a/Utils.cpp b/Utils.cpp
index 2144a3a..a33a16e 100644
--- a/Utils.cpp
+++ b/Utils.cpp
@@ -88,6 +88,7 @@ static const char* kAppObbDir = "/Android/obb/";
 
 static const char* kMediaProviderCtx = "u:r:mediaprovider:";
 static const char* kMediaProviderAppCtx = "u:r:mediaprovider_app:";
+struct selabel_handle* sehandle;
 
 // Lock used to protect process-level SELinux changes from racing with each
 // other between multiple threads.
diff --git a/Weaver1.cpp b/Weaver1.cpp
new file mode 100644
index 0000000..ea357ed
--- /dev/null
+++ b/Weaver1.cpp
@@ -0,0 +1,128 @@
+/*
+ * Copyright (C) 2017 Team Win Recovery Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/* To the best of my knowledge there is no native implementation for
+ * Weaver so I made this by looking at the IWeaver.h file that gets
+ * compiled by the build system. I took the information from this header
+ * file and looked at keymaster source to get an idea of the proper way
+ * to write the functions.
+ */
+
+#include "Weaver1.h"
+
+//#include <android-base/logging.h>
+//#include <keystore/keymaster_tags.h>
+//#include <keystore/authorization_set.h>
+//#include <keystore/keystore_hidl_support.h>
+
+#include <android/hardware/weaver/1.0/IWeaver.h>
+
+#include <iostream>
+#define ERROR 1
+#define LOG(x) std::cout
+
+using namespace android::hardware::weaver;
+using android::hardware::hidl_string;
+using ::android::hardware::weaver::V1_0::IWeaver;
+using ::android::hardware::weaver::V1_0::WeaverConfig;
+using ::android::hardware::weaver::V1_0::WeaverReadStatus;
+using ::android::hardware::weaver::V1_0::WeaverReadResponse;
+using ::android::hardware::weaver::V1_0::WeaverStatus;
+using ::android::hardware::Return;
+using ::android::sp;
+
+namespace android {
+namespace vold {
+
+Weaver::Weaver() {
+	mDevice = ::android::hardware::weaver::V1_0::IWeaver::getService();
+	GottenConfig = false;
+}
+
+bool Weaver::GetConfig() {
+	if (GottenConfig)
+		return true;
+
+	WeaverStatus status;
+	WeaverConfig cfg;
+
+	bool callbackCalled = false;
+	auto ret = mDevice->getConfig([&](WeaverStatus s, WeaverConfig c) {
+		callbackCalled = true;
+		status = s;
+		cfg = c;
+	});
+	if (ret.isOk() && callbackCalled && status == WeaverStatus::OK) {
+		config = cfg;
+		GottenConfig = true;
+		return true;
+	}
+	return false;
+}
+
+bool Weaver::GetSlots(uint32_t* slots) {
+	if (!GetConfig())
+		return false;
+	*slots = config.slots;
+	return true;
+}
+
+bool Weaver::GetKeySize(uint32_t* keySize) {
+	if (!GetConfig())
+		return false;
+	*keySize = config.keySize;
+	return true;
+}
+
+bool Weaver::GetValueSize(uint32_t* valueSize) {
+	if (!GetConfig())
+		return false;
+	*valueSize = config.valueSize;
+	return true;
+}
+
+// TODO: we should return more information about the status including time delays before the next retry
+bool Weaver::WeaverVerify(const uint32_t slot, const void* weaver_key, std::vector<uint8_t>* payload) {
+	bool callbackCalled = false;
+	WeaverReadStatus status;
+	std::vector<uint8_t> readValue;
+	uint32_t timeout;
+	uint32_t keySize;
+	if (!GetKeySize(&keySize))
+		return false;
+	std::vector<uint8_t> key;
+	key.resize(keySize);
+	uint32_t index = 0;
+	unsigned char* ptr = (unsigned char*)weaver_key;
+	for (index = 0; index < keySize; index++) {
+		key[index] = *ptr;
+		ptr++;
+	}
+	const auto readRet = mDevice->read(slot, key, [&](WeaverReadStatus s, WeaverReadResponse r) {
+		callbackCalled = true;
+		status = s;
+		readValue = r.value;
+		timeout = r.timeout;
+	});
+	if (readRet.isOk() && callbackCalled && status == WeaverReadStatus::OK && timeout == 0) {
+		*payload = readValue;
+		return true;
+	}
+	return false;
+}
+
+}  // namespace vold
+}  // namespace android
diff --git a/Weaver1.h b/Weaver1.h
new file mode 100644
index 0000000..22f401e
--- /dev/null
+++ b/Weaver1.h
@@ -0,0 +1,64 @@
+/*
+ * Copyright (C) 2017 Team Win Recovery Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/* To the best of my knowledge there is no native implementation for
+ * Weaver so I made this by looking at the IWeaver.h file that gets
+ * compiled by the build system. I took the information from this header
+ * file and looked at keymaster source to get an idea of the proper way
+ * to write the functions.
+ */
+
+#ifndef TWRP_WEAVER_H
+#define TWRP_WEAVER_H
+
+#include <memory>
+#include <string>
+#include <utility>
+
+#include <android/hardware/weaver/1.0/IWeaver.h>
+#include "Utils.h"
+
+namespace android {
+namespace vold {
+using ::android::hardware::weaver::V1_0::IWeaver;
+
+// Wrapper for a Weaver device
+class Weaver {
+	public:
+		Weaver();
+		// false if we failed to open the weaver device.
+		explicit operator bool() { return mDevice.get() != nullptr; }
+
+		bool GetSlots(uint32_t* slots);
+		bool GetKeySize(uint32_t* keySize);
+		bool GetValueSize(uint32_t* valueSize);
+		// TODO: we should return more information about the status including time delays before the next retry
+		bool WeaverVerify(const uint32_t slot, const void* weaver_key, std::vector<uint8_t>* payload);
+
+	private:
+		sp<hardware::weaver::V1_0::IWeaver> mDevice;
+		hardware::weaver::V1_0::WeaverConfig config;
+		bool GottenConfig;
+
+		bool GetConfig();
+
+		DISALLOW_COPY_AND_ASSIGN(Weaver);
+};
+
+}  // namespace vold
+}  // namespace android
+
+#endif
diff --git a/cryptfs.cpp b/cryptfs.cpp
index 91235d2..c9a143a 100644
--- a/cryptfs.cpp
+++ b/cryptfs.cpp
@@ -1213,7 +1213,7 @@ static int create_crypto_blk_dev(struct crypt_mnt_ftr* crypt_ftr, const unsigned
     return 0;
 }
 
-static int delete_crypto_blk_dev(const std::string& name) {
+int delete_crypto_blk_dev(const std::string& name) {
     bool ret;
     auto& dm = DeviceMapper::Instance();
     // TODO(b/149396179) there appears to be a race somewhere in the system where trying
diff --git a/cryptfs.h b/cryptfs.h
index 872806e..bbbbe93 100644
--- a/cryptfs.h
+++ b/cryptfs.h
@@ -71,6 +71,7 @@ int cryptfs_getfield(const char* fieldname, char* value, int len);
 int cryptfs_setfield(const char* fieldname, const char* value);
 int cryptfs_mount_default_encrypted(void);
 int cryptfs_get_password_type(void);
+int delete_crypto_blk_dev(const std::string& name);
 const char* cryptfs_get_password(void);
 void cryptfs_clear_password(void);
 int cryptfs_isConvertibleToFBE(void);
diff --git a/fscrypt-common.h b/fscrypt-common.h
new file mode 100755
index 0000000..fde5837
--- /dev/null
+++ b/fscrypt-common.h
@@ -0,0 +1,9 @@
+#include <map>
+#include <string>
+
+#define CRYPT_TYPE_DEFAULT  1
+
+// Store main DE/CE policy
+extern std::map<userid_t, android::fscrypt::EncryptionPolicy> s_de_policies;
+extern std::map<userid_t, android::fscrypt::EncryptionPolicy> s_ce_policies;
+extern std::string de_key_raw_ref;
diff --git a/fscrypt_policy.cpp b/fscrypt_policy.cpp
new file mode 100755
index 0000000..e915355
--- /dev/null
+++ b/fscrypt_policy.cpp
@@ -0,0 +1,160 @@
+/*
+ * Copyright (C) 2015 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <array>
+
+#include <asm/ioctl.h>
+#include <dirent.h>
+#include <errno.h>
+#include <fcntl.h>
+#include <linux/fs.h>
+#include <string.h>
+#include <sys/stat.h>
+#include <sys/syscall.h>
+#include <sys/types.h>
+#include <unistd.h>
+
+#include <android-base/file.h>
+#include <android-base/logging.h>
+#include <cutils/properties.h>
+#include <logwrap/logwrap.h>
+#include <utils/misc.h>
+#include <fscrypt/fscrypt.h>
+#include "KeyUtil.h"
+
+#include "fscrypt_policy.h"
+
+static int encryption_mode = FS_ENCRYPTION_MODE_PRIVATE;
+
+bool fscrypt_is_native() {
+    char value[PROPERTY_VALUE_MAX];
+    property_get("ro.crypto.type", value, "none");
+    return !strcmp(value, "file");
+}
+
+extern "C" void bytes_to_hex(const uint8_t *bytes, size_t num_bytes, char *hex) {
+  for (size_t i = 0; i < num_bytes; i++) {
+    sprintf(&hex[2 * i], "%02x", bytes[i]);
+  }
+}
+
+extern "C" bool fscrypt_set_mode() {
+    const char* mode_file = "/data/unencrypted/mode";
+    struct stat st;
+    if (stat(mode_file, &st) != 0 || st.st_size <= 0) {
+        printf("Invalid encryption mode file %s\n", mode_file);
+        return false;
+    }
+    ssize_t mode_size = st.st_size;
+    char contents_encryption_mode[mode_size + 1];
+    memset((void*)contents_encryption_mode, 0, mode_size + 1);
+    int fd = open(mode_file, O_RDONLY | O_CLOEXEC);
+    if (fd < 0) {
+        printf("error opening '%s': %s\n", mode_file, strerror(errno));
+        return false;
+    }
+    if (read(fd, contents_encryption_mode, mode_size) != mode_size) {
+        printf("read error on '%s': %s\n", mode_file, strerror(errno));
+        close(fd);
+        return false;
+    }
+    close(fd);
+
+    std::string contents_encryption_mode_string = std::string(contents_encryption_mode);
+    int pos = contents_encryption_mode_string.find(":");
+    LOG(INFO) << "contents_encryption_mode_string: " << contents_encryption_mode_string.substr(0, pos);
+
+    if (contents_encryption_mode_string.substr(0, pos) == "software") {
+        encryption_mode = FS_ENCRYPTION_MODE_AES_256_XTS;
+    } else if (contents_encryption_mode_string.substr(0, pos) == "ice") {
+        encryption_mode = FS_ENCRYPTION_MODE_PRIVATE;
+    } else {
+        printf("Invalid encryption mode '%s'\n", contents_encryption_mode);
+        return false;
+    }
+
+    printf("set encryption mode to %i\n", encryption_mode);
+    return true;
+}
+
+#ifdef USE_FSCRYPT_POLICY_V1
+extern "C" bool fscrypt_policy_set_struct(const char *directory, const struct fscrypt_policy_v1 *fep) {
+#else
+extern "C" bool fscrypt_policy_set_struct(const char *directory, const struct fscrypt_policy_v2 *fep) {
+#endif
+    int fd = open(directory, O_DIRECTORY | O_NOFOLLOW | O_CLOEXEC);
+    if (fd == -1) {
+        printf("failed to open %s\n", directory);
+        PLOG(ERROR) << "Failed to open directory " << directory;
+        return false;
+    }
+    if (android::vold::isFsKeyringSupported()) {
+        if (ioctl(fd, FS_IOC_SET_ENCRYPTION_POLICY, fep)) {
+            PLOG(ERROR) << "Failed to set encryption policy for " << directory;
+            close(fd);
+            return false;
+        }
+    } else {
+        if (ioctl(fd, FS_IOC_SET_ENCRYPTION_POLICY, fep)) {
+            PLOG(ERROR) << "Failed to set encryption policy for " << directory;
+            close(fd);
+            return false;
+        }
+    }
+    close(fd);
+    return true;
+}
+
+#ifdef USE_FSCRYPT_POLICY_V1
+extern "C" bool fscrypt_policy_get_struct(const char *directory, struct fscrypt_policy_v1 *fep) {
+#else
+extern "C" bool fscrypt_policy_get_struct(const char *directory, struct fscrypt_policy_v2 *fep) {
+#endif
+    int fd = open(directory, O_DIRECTORY | O_RDONLY | O_NOFOLLOW | O_CLOEXEC);
+    if (fd == -1) {
+        PLOG(ERROR) << "Failed to open directory " << directory;
+        return false;
+    }
+#ifdef USE_FSCRYPT_POLICY_V1
+    memset(fep, 0, sizeof(fscrypt_policy_v1));
+#else
+    memset(fep, 0, sizeof(fscrypt_policy_v2));
+#endif
+    struct fscrypt_get_policy_ex_arg ex_policy = {0};
+
+    if (android::vold::isFsKeyringSupported()) {
+        ex_policy.policy_size = sizeof(ex_policy.policy);
+        if (ioctl(fd, FS_IOC_GET_ENCRYPTION_POLICY_EX, &ex_policy) != 0) {
+            PLOG(ERROR) << "Failed to get encryption policy for " << directory;
+            close(fd);
+            return false;
+        }
+#ifdef USE_FSCRYPT_POLICY_V1
+        memcpy(fep, &ex_policy.policy.v1, sizeof(ex_policy.policy.v1));
+#else
+        memcpy(fep, &ex_policy.policy.v2, sizeof(ex_policy.policy.v2));
+#endif
+    } else {
+        if (ioctl(fd, FS_IOC_GET_ENCRYPTION_POLICY, &ex_policy.policy.v1) != 0) {
+            PLOG(ERROR) << "Failed to get encryption policy for " << directory;
+            close(fd);
+            return false;
+        }
+        memcpy(fep, &ex_policy.policy.v1, sizeof(ex_policy.policy.v1));
+    }
+    close(fd);
+    return true;
+}
diff --git a/fscrypt_policy.h b/fscrypt_policy.h
new file mode 100755
index 0000000..5714790
--- /dev/null
+++ b/fscrypt_policy.h
@@ -0,0 +1,87 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef _FS_CRYPT_H_
+#define _FS_CRYPT_H_
+
+#include <sys/cdefs.h>
+#include <stdbool.h>
+#include <cutils/multiuser.h>
+#include <linux/fs.h>
+
+__BEGIN_DECLS
+
+#define FS_KEY_DESCRIPTOR_SIZE_HEX (2 * FS_KEY_DESCRIPTOR_SIZE + 1)
+#define FSCRYPT_KEY_IDENTIFIER_HEX_SIZE ((2 * FSCRYPT_KEY_IDENTIFIER_SIZE) + 1)
+
+#ifdef USE_FSCRYPT_POLICY_V1
+#define USER_CE_FSCRYPT_POLICY           "0CE"
+#define USER_DE_FSCRYPT_POLICY           "0DE"
+#define SYSTEM_DE_FSCRYPT_POLICY         "0DK"
+#else
+#define USER_CE_FSCRYPT_POLICY           "2CE"
+#define USER_DE_FSCRYPT_POLICY           "2DE"
+#define SYSTEM_DE_FSCRYPT_POLICY         "2DK"
+#endif
+
+#define FSCRYPT_V1                        "0"
+#define FSCRYPT_V2                        "2"
+#define SYSTEM_DE_KEY                     "DK"
+#define USER_CE_KEY                       "C"
+#define USER_DE_KEY                       "D"
+
+/* modes not supported by upstream kernel, so not in <linux/fs.h> */
+#define FS_ENCRYPTION_MODE_AES_256_HEH      126
+#define FS_ENCRYPTION_MODE_PRIVATE          127
+
+/* new definition, not yet in Bionic's <linux/fs.h> */
+#ifndef FS_ENCRYPTION_MODE_ADIANTUM
+#define FS_ENCRYPTION_MODE_ADIANTUM         9
+#endif
+
+/* new definition, not yet in Bionic's <linux/fs.h> */
+#ifndef FS_POLICY_FLAG_DIRECT_KEY
+#define FS_POLICY_FLAG_DIRECT_KEY           0x4
+#endif
+
+#define HEX_LOOKUP "0123456789abcdef"
+
+bool fscrypt_set_mode();
+
+#ifdef USE_FSCRYPT_POLICY_V1
+bool lookup_ref_key(struct fscrypt_policy_v1 *fep, uint8_t* policy_type);
+#else
+bool lookup_ref_key(struct fscrypt_policy_v2 *fep, uint8_t* policy_type);
+#endif
+
+bool lookup_ref_tar(const uint8_t *policy_type, uint8_t *policy);
+
+#ifdef USE_FSCRYPT_POLICY_V1
+bool fscrypt_policy_get_struct(const char *directory, struct fscrypt_policy_v1  *fep);
+#else
+bool fscrypt_policy_get_struct(const char *directory, struct fscrypt_policy_v2  *fep);
+#endif
+
+#ifdef USE_FSCRYPT_POLICY_V1
+bool fscrypt_policy_set_struct(const char *directory, const struct fscrypt_policy_v1  *fep);
+#else
+bool fscrypt_policy_set_struct(const char *directory, const struct fscrypt_policy_v2  *fep);
+#endif
+
+void bytes_to_hex(const uint8_t *bytes, size_t num_bytes, char *hex);
+__END_DECLS
+
+#endif // _FS_CRYPT_H_
diff --git a/fscryptpolicyget.cpp b/fscryptpolicyget.cpp
new file mode 100755
index 0000000..189a428
--- /dev/null
+++ b/fscryptpolicyget.cpp
@@ -0,0 +1,47 @@
+/*
+ * Copyright (C) 2016 Team Win Recovery Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include "fscrypt_policy.h"
+#include "fscrypt/fscrypt.h"
+
+int main(int argc, char *argv[]) {
+	if (argc != 2) {
+		printf("Must specify a path\n");
+		return -1;
+	} else  {
+#ifdef USE_FSCRYPT_POLICY_V1
+		fscrypt_policy_v1 fep;
+#else
+		fscrypt_policy_v2 fep;
+#endif
+		if (fscrypt_policy_get_struct(argv[1], &fep)) {
+#ifdef USE_FSCRYPT_POLICY_V1
+			char policy_hex[FS_KEY_DESCRIPTOR_SIZE_HEX];
+			bytes_to_hex(fep.master_key_descriptor, FS_KEY_DESCRIPTOR_SIZE, policy_hex);
+#else
+			char policy_hex[FSCRYPT_KEY_IDENTIFIER_HEX_SIZE];
+			bytes_to_hex(fep.master_key_identifier, FSCRYPT_KEY_IDENTIFIER_SIZE, policy_hex);
+#endif
+			printf("%s\n", policy_hex);
+		} else {
+			printf("No policy set\n");
+		}
+	}
+	return 0;
+}
-- 
2.36.1

