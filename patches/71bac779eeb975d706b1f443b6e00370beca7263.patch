From 71bac779eeb975d706b1f443b6e00370beca7263 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Yilli=C3=A9?= <yilliee@protonmail.com>
Date: Mon, 4 Oct 2021 14:26:52 +0500
Subject: [PATCH] Allow to specify the status bar left and right padding

---
 Android.mk       |   26 +
 Android.mk.orig  |  737 ++++++++++++++++++++++++++++
 data.cpp         |    2 +
 data.cpp.orig    | 1193 ++++++++++++++++++++++++++++++++++++++++++++++
 variables.h      |    2 +
 variables.h.orig |  182 +++++++
 6 files changed, 2142 insertions(+)
 create mode 100755 Android.mk.orig
 create mode 100755 data.cpp.orig
 create mode 100755 variables.h.orig

diff --git a/Android.mk b/Android.mk
index 678c2cfda9..5b621ab05a 100755
--- a/Android.mk
+++ b/Android.mk
@@ -403,6 +403,32 @@ else ifeq ($(TW_THEME),landscape_mdpi)
 else ifeq ($(TW_THEME),watch_mdpi)
        LOCAL_CFLAGS += -DTW_CLOCK_POS_X='"160"'
 endif
+ifneq ($(TW_STATUSBAR_PADDING_LEFT),)
+	LOCAL_CFLAGS += -DTW_STATUSBAR_PADDING_LEFT=$(TW_STATUSBAR_PADDING_LEFT)
+else ifeq ($(TW_THEME),portrait_hdpi)
+	LOCAL_CFLAGS += -DTW_STATUSBAR_PADDING_LEFT='"36"'
+else ifeq ($(TW_THEME),portrait_mdpi)
+	LOCAL_CFLAGS += -DTW_STATUSBAR_PADDING_LEFT='"15"'
+else ifeq ($(TW_THEME),landscape_hdpi)
+	LOCAL_CFLAGS += -DTW_STATUSBAR_PADDING_LEFT='"24"'
+else ifeq ($(TW_THEME),landscape_mdpi)
+	LOCAL_CFLAGS += -DTW_STATUSBAR_PADDING_LEFT='"10"'
+else ifeq ($(TW_THEME),watch_mdpi)
+	LOCAL_CFLAGS += -DTW_STATUSBAR_PADDING_LEFT='"8"'
+endif
+ifneq ($(TW_STATUSBAR_PADDING_RIGHT),)
+        LOCAL_CFLAGS += -DTW_STATUSBAR_PADDING_RIGHT=$(TW_STATUSBAR_PADDING_RIGHT)
+else ifeq ($(TW_THEME),portrait_hdpi)
+        LOCAL_CFLAGS += -DTW_STATUSBAR_PADDING_RIGHT='"1044"'
+else ifeq ($(TW_THEME),portrait_mdpi)
+        LOCAL_CFLAGS += -DTW_STATUSBAR_PADDING_RIGHT='"465"'
+else ifeq ($(TW_THEME),landscape_hdpi)
+        LOCAL_CFLAGS += -DTW_STATUSBAR_PADDING_RIGHT='"1896"'
+else ifeq ($(TW_THEME),landscape_mdpi)
+        LOCAL_CFLAGS += -DTW_STATUSBAR_PADDING_RIGHT='"790"'
+else ifeq ($(TW_THEME),watch_mdpi)
+        LOCAL_CFLAGS += -DTW_STATUSBAR_PADDING_RIGHT='"312"'
+endif
 ifneq ($(TW_OVERRIDE_SYSTEM_PROPS),)
     TW_INCLUDE_LIBRESETPROP := true
     LOCAL_CFLAGS += -DTW_OVERRIDE_SYSTEM_PROPS=$(TW_OVERRIDE_SYSTEM_PROPS)
diff --git a/Android.mk.orig b/Android.mk.orig
new file mode 100755
index 0000000000..678c2cfda9
--- /dev/null
+++ b/Android.mk.orig
@@ -0,0 +1,737 @@
+# Copyright (C) 2007 The Android Open Source Project
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#      http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+LOCAL_PATH := $(call my-dir)
+commands_TWRP_local_path := $(LOCAL_PATH)
+
+ifneq ($(project-path-for),)
+    ifeq ($(LOCAL_PATH),$(call project-path-for,recovery))
+        PROJECT_PATH_AGREES := true
+        BOARD_SEPOLICY_DIRS += $(call project-path-for,recovery)/sepolicy
+    endif
+else
+    ifeq ($(LOCAL_PATH),bootable/recovery)
+        PROJECT_PATH_AGREES := true
+        BOARD_SEPOLICY_DIRS += bootable/recovery/sepolicy
+    else
+        ifeq ($(LOCAL_PATH),bootable/recovery-twrp)
+            ifeq ($(RECOVERY_VARIANT),twrp)
+                PROJECT_PATH_AGREES := true
+                BOARD_SEPOLICY_DIRS += bootable/recovery-twrp/sepolicy
+            endif
+        endif
+    endif
+endif
+
+ifeq ($(PROJECT_PATH_AGREES),true)
+
+ifeq ($(CM_PLATFORM_SDK_VERSION),)
+    CM_PLATFORM_SDK_VERSION := 0
+endif
+
+include $(CLEAR_VARS)
+
+TARGET_RECOVERY_GUI := true
+
+LOCAL_STATIC_LIBRARIES :=
+LOCAL_SHARED_LIBRARIES :=
+
+ifneq ($(TW_DEVICE_VERSION),)
+    LOCAL_CFLAGS += -DTW_DEVICE_VERSION='"-$(TW_DEVICE_VERSION)"'
+else
+    LOCAL_CFLAGS += -DTW_DEVICE_VERSION='"-0"'
+endif
+LOCAL_CFLAGS += -DPLATFORM_SDK_VERSION=$(PLATFORM_SDK_VERSION)
+
+LOCAL_SRC_FILES := \
+    twrp.cpp \
+    fixContexts.cpp \
+    twrpTar.cpp \
+    exclude.cpp \
+    find_file.cpp \
+    infomanager.cpp \
+    data.cpp \
+    partition.cpp \
+    partitionmanager.cpp \
+    progresstracking.cpp \
+    startupArgs.cpp \
+    twrp-functions.cpp \
+    twrpDigestDriver.cpp \
+    openrecoveryscript.cpp \
+    tarWrite.c \
+    twrpAdbBuFifo.cpp \
+    twrpRepacker.cpp
+
+ifeq ($(TW_EXCLUDE_APEX),)
+    LOCAL_SRC_FILES += twrpApex.cpp
+else
+    LOCAL_CFLAGS += -DTW_EXCLUDE_APEX
+endif
+
+LOCAL_STATIC_LIBRARIES += libavb libtwrpinstall libminadbd_services libinit libsnapshot_nobinder
+LOCAL_SHARED_LIBRARIES += libfs_mgr libhardware android.hardware.boot@1.0 android.hardware.boot@1.1 libprotobuf-cpp-lite liblp libutils libhidlbase
+LOCAL_C_INCLUDES += \
+    system/core/fs_mgr/libfs_avb/include/ \
+    system/core/fs_mgr/include_fstab/ \
+    system/core/fs_mgr/include/ \
+    system/core/fs_mgr/libdm/include/ \
+    system/core/fs_mgr/liblp/include/ \
+    system/gsid/include/ \
+    system/core/init/ \
+    system/extras/ext4_utils/include \
+
+ifneq ($(TARGET_RECOVERY_REBOOT_SRC),)
+  LOCAL_SRC_FILES += $(TARGET_RECOVERY_REBOOT_SRC)
+endif
+
+LOCAL_MODULE := recovery
+
+RECOVERY_API_VERSION := 3
+RECOVERY_FSTAB_VERSION := 2
+LOCAL_CFLAGS += -DRECOVERY_API_VERSION=$(RECOVERY_API_VERSION)
+LOCAL_CFLAGS += -Wno-unused-parameter -Wno-unused-function
+LOCAL_CLANG := true
+
+LOCAL_C_INCLUDES += \
+    bionic \
+    system/extras \
+    system/core/adb \
+    system/core/libsparse \
+    external/zlib \
+    system/core/libziparchive/include \
+    external/freetype/include \
+    external/boringssl/include \
+    external/libcxx/include \
+    external/libselinux/include \
+    external/libpng \
+    $(LOCAL_PATH)/gui/include \
+    $(LOCAL_PATH)/recovery_ui/include \
+    $(LOCAL_PATH)/otautil/include \
+    $(LOCAL_PATH)/install/include \
+    $(LOCAL_PATH)/fuse_sideload/include \
+    $(LOCAL_PATH)/install/include \
+    $(LOCAL_PATH)/twrpinstall/include \
+    $(LOCAL_PATH)/recovery_utils/include \
+    $(LOCAL_PATH)/libpixelflinger/include \
+    $(LOCAL_PATH)/minuitwrp/include \
+    $(LOCAL_PATH)/twinstall/include
+
+LOCAL_STATIC_LIBRARIES += libguitwrp
+LOCAL_SHARED_LIBRARIES += libz libc libcutils libstdc++ libtar libblkid libminuitwrp libmtdutils libtwadbbu 
+LOCAL_SHARED_LIBRARIES += libbootloader_message libcrecovery libtwrpdigest libc++ libaosprecovery libcrypto libbase 
+LOCAL_SHARED_LIBRARIES += libziparchive libselinux libdl_android.bootstrap
+
+ifneq ($(wildcard system/core/libsparse/Android.mk),)
+LOCAL_SHARED_LIBRARIES += libsparse
+endif
+
+ifeq ($(TW_OEM_BUILD),true)
+    LOCAL_CFLAGS += -DTW_OEM_BUILD
+    BOARD_HAS_NO_REAL_SDCARD := true
+    TW_USE_TOOLBOX := true
+    TW_EXCLUDE_MTP := true
+    TW_EXCLUDE_TZDATA := true
+    TW_EXCLUDE_NANO := true
+    TW_EXCLUDE_BASH := true
+endif
+
+ifeq ($(AB_OTA_UPDATER),true)
+    LOCAL_CFLAGS += -DAB_OTA_UPDATER=1
+    TWRP_REQUIRED_MODULES += libhardware android.hardware.boot@1.0-service android.hardware.boot@1.0-service.rc \
+    android.hardware.boot@1.1-service android.hardware.boot@1.1-service.rc android.hardware.boot@1.1.xml
+endif
+
+ifeq ($(PRODUCT_USE_DYNAMIC_PARTITIONS),true)
+    LOCAL_CFLAGS += -DPRODUCT_USE_DYNAMIC_PARTITIONS=1
+    TWRP_REQUIRED_MODULES += android.hardware.health@2.1-service android.hardware.health@2.1-impl.recovery android.hardware.health@2.1-service.rc android.hardware.health@2.1.xml
+    TWRP_REQUIRED_MODULES += android.hardware.health@2.0-service android.hardware.health@2.0-impl.recovery android.hardware.health@2.0-service.rc
+    ifeq ($(TW_EXCLUDE_LPDUMP),)
+        TWRP_REQUIRED_MODULES += lpdump lpdumpd.rc
+    endif
+    ifeq ($(TW_EXCLUDE_LPTOOLS),)
+        TWRP_REQUIRED_MODULES += lptools
+    endif
+endif
+
+ifneq ($(TW_SYSTEM_BUILD_PROP_ADDITIONAL_PATHS),)
+    LOCAL_CFLAGS += -DTW_SYSTEM_BUILD_PROP_ADDITIONAL_PATHS='"$(TW_SYSTEM_BUILD_PROP_ADDITIONAL_PATHS)"'
+endif
+
+ifeq ($(TW_USES_VENDOR_LIBS),true)
+    LOCAL_CFLAGS += -DUSE_VENDOR_LIBS=1
+endif
+
+ifeq ($(TW_NO_BIND_SYSTEM),true)
+    LOCAL_CFLAGS += -DTW_NO_BIND_SYSTEM
+endif
+
+LOCAL_MODULE_PATH := $(TARGET_RECOVERY_ROOT_OUT)/system/bin
+
+ifeq ($(TARGET_RECOVERY_TWRP_LIB),)
+    LOCAL_SRC_FILES += BasePartition.cpp
+else
+    LOCAL_STATIC_LIBRARIES += $(TARGET_RECOVERY_TWRP_LIB)
+endif
+
+LOCAL_C_INCLUDES += system/extras/ext4_utils
+
+tw_git_revision := $(shell git -C $(LOCAL_PATH) rev-parse --short=8 HEAD 2>/dev/null)
+ifeq ($(shell git -C $(LOCAL_PATH) diff --quiet; echo $$?),1)
+    tw_git_revision := $(tw_git_revision)-dirty
+endif
+LOCAL_CFLAGS += -DTW_GIT_REVISION='"$(tw_git_revision)"'
+
+ifeq ($(TW_FORCE_USE_BUSYBOX), true)
+    TW_USE_TOOLBOX := false
+else
+    TW_USE_TOOLBOX := true
+endif
+ifeq ($(TW_EXCLUDE_MTP),)
+    LOCAL_SHARED_LIBRARIES += libtwrpmtp-ffs
+endif
+ifeq ($(BOARD_USES_RECOVERY_AS_BOOT), true)
+    LOCAL_CFLAGS += -DBOARD_USES_RECOVERY_AS_BOOT
+endif
+ifeq ($(BOARD_BUILD_SYSTEM_ROOT_IMAGE), true)
+    LOCAL_CFLAGS += -DBOARD_BUILD_SYSTEM_ROOT_IMAGE
+endif
+
+#TWRP Build Flags
+ifeq ($(TW_EXCLUDE_MTP),)
+    LOCAL_CFLAGS += -DTW_HAS_MTP
+endif
+ifneq ($(TW_NO_SCREEN_TIMEOUT),)
+    LOCAL_CFLAGS += -DTW_NO_SCREEN_TIMEOUT
+endif
+ifeq ($(BOARD_HAS_NO_REAL_SDCARD), true)
+    LOCAL_CFLAGS += -DBOARD_HAS_NO_REAL_SDCARD
+endif
+ifneq ($(RECOVERY_SDCARD_ON_DATA),)
+	LOCAL_CFLAGS += -DRECOVERY_SDCARD_ON_DATA
+endif
+ifneq ($(TW_INCLUDE_DUMLOCK),)
+	LOCAL_CFLAGS += -DTW_INCLUDE_DUMLOCK
+endif
+ifneq ($(TW_INTERNAL_STORAGE_PATH),)
+	LOCAL_CFLAGS += -DTW_INTERNAL_STORAGE_PATH=$(TW_INTERNAL_STORAGE_PATH)
+endif
+ifneq ($(TW_INTERNAL_STORAGE_MOUNT_POINT),)
+	LOCAL_CFLAGS += -DTW_INTERNAL_STORAGE_MOUNT_POINT=$(TW_INTERNAL_STORAGE_MOUNT_POINT)
+endif
+ifneq ($(TW_EXTERNAL_STORAGE_PATH),)
+	LOCAL_CFLAGS += -DTW_EXTERNAL_STORAGE_PATH=$(TW_EXTERNAL_STORAGE_PATH)
+endif
+ifneq ($(TW_EXTERNAL_STORAGE_MOUNT_POINT),)
+	LOCAL_CFLAGS += -DTW_EXTERNAL_STORAGE_MOUNT_POINT=$(TW_EXTERNAL_STORAGE_MOUNT_POINT)
+endif
+ifeq ($(TW_HAS_NO_BOOT_PARTITION), true)
+    LOCAL_CFLAGS += -DTW_HAS_NO_BOOT_PARTITION
+endif
+ifeq ($(TW_NO_REBOOT_BOOTLOADER), true)
+    LOCAL_CFLAGS += -DTW_NO_REBOOT_BOOTLOADER
+endif
+ifeq ($(TW_NO_REBOOT_RECOVERY), true)
+    LOCAL_CFLAGS += -DTW_NO_REBOOT_RECOVERY
+endif
+ifeq ($(TW_NO_BATT_PERCENT), true)
+    LOCAL_CFLAGS += -DTW_NO_BATT_PERCENT
+endif
+ifeq ($(TW_NO_CPU_TEMP), true)
+    LOCAL_CFLAGS += -DTW_NO_CPU_TEMP
+endif
+ifneq ($(TW_CUSTOM_POWER_BUTTON),)
+	LOCAL_CFLAGS += -DTW_CUSTOM_POWER_BUTTON=$(TW_CUSTOM_POWER_BUTTON)
+endif
+ifeq ($(TW_ALWAYS_RMRF), true)
+    LOCAL_CFLAGS += -DTW_ALWAYS_RMRF
+endif
+ifeq ($(TW_NEVER_UNMOUNT_SYSTEM), true)
+    LOCAL_CFLAGS += -DTW_NEVER_UNMOUNT_SYSTEM
+endif
+ifeq ($(TW_NO_USB_STORAGE), true)
+    LOCAL_CFLAGS += -DTW_NO_USB_STORAGE
+endif
+ifeq ($(TW_INCLUDE_INJECTTWRP), true)
+    LOCAL_CFLAGS += -DTW_INCLUDE_INJECTTWRP
+endif
+ifeq ($(TW_INCLUDE_BLOBPACK), true)
+    LOCAL_CFLAGS += -DTW_INCLUDE_BLOBPACK
+endif
+ifneq ($(TARGET_USE_CUSTOM_LUN_FILE_PATH),)
+    LOCAL_CFLAGS += -DCUSTOM_LUN_FILE=\"$(TARGET_USE_CUSTOM_LUN_FILE_PATH)\"
+endif
+ifneq ($(BOARD_UMS_LUNFILE),)
+    LOCAL_CFLAGS += -DCUSTOM_LUN_FILE=\"$(BOARD_UMS_LUNFILE)\"
+endif
+ifeq ($(TW_HAS_DOWNLOAD_MODE), true)
+    LOCAL_CFLAGS += -DTW_HAS_DOWNLOAD_MODE
+endif
+ifeq ($(TW_HAS_EDL_MODE), true)
+    LOCAL_CFLAGS += -DTW_HAS_EDL_MODE
+endif
+ifeq ($(TW_NO_SCREEN_BLANK), true)
+    LOCAL_CFLAGS += -DTW_NO_SCREEN_BLANK
+endif
+ifeq ($(TW_SDEXT_NO_EXT4), true)
+    LOCAL_CFLAGS += -DTW_SDEXT_NO_EXT4
+endif
+ifeq ($(TW_FORCE_CPUINFO_FOR_DEVICE_ID), true)
+    LOCAL_CFLAGS += -DTW_FORCE_CPUINFO_FOR_DEVICE_ID
+endif
+ifeq ($(TW_NO_EXFAT_FUSE), true)
+    LOCAL_CFLAGS += -DTW_NO_EXFAT_FUSE
+endif
+ifeq ($(TW_NO_HAPTICS), true)
+    LOCAL_CFLAGS += -DTW_NO_HAPTICS
+endif
+ifeq ($(TW_INCLUDE_JB_CRYPTO), true)
+    TW_INCLUDE_CRYPTO := true
+endif
+ifeq ($(TW_INCLUDE_L_CRYPTO), true)
+    TW_INCLUDE_CRYPTO := true
+endif
+ifneq ($(TW_ADDITIONAL_APEX_FILES),)
+    LOCAL_CFLAGS += -DTW_ADDITIONAL_APEX_FILES=$(TW_ADDITIONAL_APEX_FILES)
+endif
+ifneq ($(TW_LOAD_VENDOR_MODULES),)
+    LOCAL_SRC_FILES += kernel_module_loader.cpp
+    LOCAL_C_INCLUDES += system/core/libmodprobe/include
+    LOCAL_STATIC_LIBRARIES += libmodprobe
+    LOCAL_CFLAGS += -DTW_LOAD_VENDOR_MODULES=$(TW_LOAD_VENDOR_MODULES)
+endif
+ifeq ($(TW_INCLUDE_CRYPTO), true)
+    LOCAL_CFLAGS += -DTW_INCLUDE_CRYPTO -DUSE_FSCRYPT -Wno-macro-redefined
+    LOCAL_SHARED_LIBRARIES += libcryptfsfde
+    LOCAL_SHARED_LIBRARIES += libgpt_twrp libstatssocket.recovery
+    LOCAL_C_INCLUDES += external/boringssl/src/include bootable/recovery/crypto
+    LOCAL_C_INCLUDES += $(commands_TWRP_local_path)/crypto/fscrypt
+    TW_INCLUDE_CRYPTO_FBE := true
+    LOCAL_CFLAGS += -DTW_INCLUDE_FBE
+    LOCAL_SHARED_LIBRARIES += libtwrpfscrypt android.frameworks.stats@1.0 android.hardware.authsecret@1.0 \
+        android.hardware.oemlock@1.0
+    LOCAL_CFLAGS += -DTW_INCLUDE_FBE_METADATA_DECRYPT
+    ifneq ($(TW_CRYPTO_USE_SYSTEM_VOLD),)
+    ifneq ($(TW_CRYPTO_USE_SYSTEM_VOLD),false)
+		TW_INCLUDE_LIBRESETPROP := true
+        LOCAL_CFLAGS += -DTW_CRYPTO_USE_SYSTEM_VOLD
+        LOCAL_STATIC_LIBRARIES += libvolddecrypt
+    endif
+    endif
+endif
+WITH_CRYPTO_UTILS := \
+    $(if $(wildcard system/core/libcrypto_utils/android_pubkey.c),true)
+ifeq ($(TW_USE_MODEL_HARDWARE_ID_FOR_DEVICE_ID), true)
+    LOCAL_CFLAGS += -DTW_USE_MODEL_HARDWARE_ID_FOR_DEVICE_ID
+endif
+ifeq ($(TW_USE_SERIALNO_PROPERTY_FOR_DEVICE_ID), true)
+    LOCAL_CFLAGS += -DTW_USE_SERIALNO_PROPERTY_FOR_DEVICE_ID
+endif
+ifneq ($(TW_BRIGHTNESS_PATH),)
+	LOCAL_CFLAGS += -DTW_BRIGHTNESS_PATH=$(TW_BRIGHTNESS_PATH)
+endif
+ifneq ($(TW_SECONDARY_BRIGHTNESS_PATH),)
+	LOCAL_CFLAGS += -DTW_SECONDARY_BRIGHTNESS_PATH=$(TW_SECONDARY_BRIGHTNESS_PATH)
+endif
+ifneq ($(TW_MAX_BRIGHTNESS),)
+	LOCAL_CFLAGS += -DTW_MAX_BRIGHTNESS=$(TW_MAX_BRIGHTNESS)
+endif
+ifneq ($(TW_DEFAULT_BRIGHTNESS),)
+	LOCAL_CFLAGS += -DTW_DEFAULT_BRIGHTNESS=$(TW_DEFAULT_BRIGHTNESS)
+endif
+ifneq ($(TW_CUSTOM_BATTERY_PATH),)
+	LOCAL_CFLAGS += -DTW_CUSTOM_BATTERY_PATH=$(TW_CUSTOM_BATTERY_PATH)
+endif
+ifneq ($(TW_CUSTOM_CPU_TEMP_PATH),)
+	LOCAL_CFLAGS += -DTW_CUSTOM_CPU_TEMP_PATH=$(TW_CUSTOM_CPU_TEMP_PATH)
+endif
+ifneq ($(TW_EXCLUDE_ENCRYPTED_BACKUPS),)
+    LOCAL_SHARED_LIBRARIES += libopenaes
+else
+    LOCAL_CFLAGS += -DTW_EXCLUDE_ENCRYPTED_BACKUPS
+endif
+ifeq ($(TARGET_RECOVERY_QCOM_RTC_FIX),)
+  ifneq ($(filter msm8226 msm8x26 msm8610 msm8974 msm8x74 msm8084 msm8x84 apq8084 msm8909 msm8916 msm8992 msm8994 msm8952 msm8996 msm8937 msm8953 msm8998,$(TARGET_BOARD_PLATFORM)),)
+    LOCAL_CFLAGS += -DQCOM_RTC_FIX
+  else ifeq ($(TARGET_CPU_VARIANT),krait)
+    LOCAL_CFLAGS += -DQCOM_RTC_FIX
+  endif
+else ifeq ($(TARGET_RECOVERY_QCOM_RTC_FIX),true)
+    LOCAL_CFLAGS += -DQCOM_RTC_FIX
+endif
+ifneq ($(TW_NO_LEGACY_PROPS),)
+	LOCAL_CFLAGS += -DTW_NO_LEGACY_PROPS
+endif
+ifneq ($(wildcard bionic/libc/include/sys/capability.h),)
+    LOCAL_CFLAGS += -DHAVE_CAPABILITIES
+endif
+ifneq ($(TARGET_RECOVERY_INITRC),)
+    TW_EXCLUDE_DEFAULT_USB_INIT := true
+endif
+LOCAL_CFLAGS += -DTW_USE_NEW_MINADBD
+ifneq ($(TW_DEFAULT_LANGUAGE),)
+    LOCAL_CFLAGS += -DTW_DEFAULT_LANGUAGE=$(TW_DEFAULT_LANGUAGE)
+else
+    LOCAL_CFLAGS += -DTW_DEFAULT_LANGUAGE=en
+endif
+ifneq ($(TW_QCOM_ATS_OFFSET),)
+	LOCAL_CFLAGS += -DTW_QCOM_ATS_OFFSET=$(TW_QCOM_ATS_OFFSET)
+endif
+ifneq ($(TW_CLOCK_OFFSET),)
+	LOCAL_CFLAGS += -DTW_CLOCK_OFFSET=$(TW_CLOCK_OFFSET)
+endif
+ifneq ($(TW_CLOCK_POS_X),)
+       LOCAL_CFLAGS += -DTW_CLOCK_POS_X=$(TW_CLOCK_POS_X)
+else ifeq ($(TW_THEME),portrait_hdpi)
+       LOCAL_CFLAGS += -DTW_CLOCK_POS_X='"850"'
+else ifeq ($(TW_THEME),portrait_mdpi)
+       LOCAL_CFLAGS += -DTW_CLOCK_POS_X='"240"'
+else ifeq ($(TW_THEME),landscape_hdpi)
+       LOCAL_CFLAGS += -DTW_CLOCK_POS_X='"960"'
+else ifeq ($(TW_THEME),landscape_mdpi)
+       LOCAL_CFLAGS += -DTW_CLOCK_POS_X='"400"'
+else ifeq ($(TW_THEME),watch_mdpi)
+       LOCAL_CFLAGS += -DTW_CLOCK_POS_X='"160"'
+endif
+ifneq ($(TW_OVERRIDE_SYSTEM_PROPS),)
+    TW_INCLUDE_LIBRESETPROP := true
+    LOCAL_CFLAGS += -DTW_OVERRIDE_SYSTEM_PROPS=$(TW_OVERRIDE_SYSTEM_PROPS)
+endif
+ifneq ($(TW_OVERRIDE_PROPS_ADDITIONAL_PARTITIONS),)
+    LOCAL_CFLAGS += -DTW_OVERRIDE_PROPS_ADDITIONAL_PARTITIONS='"$(TW_OVERRIDE_PROPS_ADDITIONAL_PARTITIONS)"'
+endif
+ifneq ($(TW_INCLUDE_LIBRESETPROP),)
+    LOCAL_SHARED_LIBRARIES += libresetprop
+    LOCAL_C_INCLUDES += external/magisk-prebuilt/include
+    LOCAL_CFLAGS += -DTW_INCLUDE_LIBRESETPROP
+endif
+ifeq ($(TW_EXCLUDE_NANO), true)
+    LOCAL_CFLAGS += -DTW_EXCLUDE_NANO
+endif
+ifneq ($(TARGET_OTA_ASSERT_DEVICE),)
+    LOCAL_CFLAGS += -DTARGET_OTA_ASSERT_DEVICE='"$(TARGET_OTA_ASSERT_DEVICE)"'
+endif
+
+LOCAL_C_INCLUDES += system/vold \
+
+TWRP_REQUIRED_MODULES += \
+    relink_libraries \
+    relink_binaries \
+    twrp_ramdisk \
+    bc \
+    dump_image \
+    erase_image \
+    flash_image \
+    mke2fs.conf \
+    pigz \
+    teamwin \
+    twrp \
+    fsck.fat \
+    fatlabel \
+    mkfs.fat \
+    permissive.sh \
+    simg2img_twrp \
+    libbootloader_message \
+    init.recovery.hlthchrg.rc \
+    init.recovery.service.rc \
+    init.recovery.ldconfig.rc \
+    awk \
+    toybox \
+    toolbox \
+    mkshrc_twrp \
+    plat_hwservice_contexts \
+    vendor_hwservice_contexts \
+    minadbd \
+    twrpbu \
+    adbd_system_api_recovery \
+    me.twrp.twrpapp.apk \
+    privapp-permissions-twrpapp.xml \
+    adbd_system_api_recovery \
+    libsync.recovery
+
+ifneq ($(TW_EXCLUDE_TZDATA), true)
+TWRP_REQUIRED_MODULES += \
+    tzdata_twrp
+endif
+
+ifneq ($(TW_EXCLUDE_NANO), true)
+TWRP_REQUIRED_MODULES += \
+    nano_twrp \
+    nano.rc
+endif
+
+ifneq ($(TW_EXCLUDE_BASH), true)
+    ifneq ($(wildcard external/bash/.),)
+    TWRP_REQUIRED_MODULES += \
+        bash_twrp
+    endif
+endif
+
+ifeq ($(TW_INCLUDE_REPACKTOOLS), true)
+TWRP_REQUIRED_MODULES += \
+    magiskboot
+endif
+
+ifeq ($(TW_INCLUDE_RESETPROP), true)
+TWRP_REQUIRED_MODULES += \
+    resetprop
+endif
+
+TWRP_REQUIRED_MODULES += \
+    hwservicemanager \
+    hwservicemanager.rc \
+    vndservicemanager \
+    vndservicemanager.rc
+
+ifneq ($(TW_INCLUDE_CRYPTO),)
+TWRP_REQUIRED_MODULES += \
+    vold_prepare_subdirs \
+    task_recovery_profiles.json \
+    fscryptpolicyget
+    ifneq ($(TW_INCLUDE_CRYPTO_FBE),)
+    TWRP_REQUIRED_MODULES += \
+        plat_service_contexts \
+        servicemanager \
+        servicemanager.rc
+    endif
+endif
+
+ifneq ($(wildcard external/zip/Android.mk),)
+    TWRP_REQUIRED_MODULES += zip
+endif
+ifneq ($(wildcard external/unzip/Android.mk),)
+    TWRP_REQUIRED_MODULES += unzip
+endif
+
+ifneq ($(TW_NO_EXFAT), true)
+    TWRP_REQUIRED_MODULES += mkexfatfs fsckexfat
+    ifneq ($(TW_NO_EXFAT_FUSE), true)
+        TWRP_REQUIRED_MODULES += exfat-fuse
+    endif
+endif
+ifeq ($(BOARD_HAS_NO_REAL_SDCARD),)
+    TWRP_REQUIRED_MODULES += sgdisk
+endif
+ifneq ($(TW_EXCLUDE_ENCRYPTED_BACKUPS),)
+    TWRP_REQUIRED_MODULES += openaes openaes_license
+endif
+ifeq ($(TW_INCLUDE_DUMLOCK), true)
+    TWRP_REQUIRED_MODULES += \
+        htcdumlock htcdumlocksys flash_imagesys dump_imagesys libbmlutils.so \
+        libflashutils.so libmmcutils.so libmtdutils.so HTCDumlock.apk
+endif
+ifeq ($(TW_INCLUDE_FB2PNG), true)
+    TWRP_REQUIRED_MODULES += fb2png
+endif
+ifneq ($(TW_OEM_BUILD),true)
+    TWRP_REQUIRED_MODULES += orscmd
+endif
+ifeq ($(BOARD_USES_BML_OVER_MTD),true)
+    TWRP_REQUIRED_MODULES += bml_over_mtd
+endif
+ifeq ($(TW_INCLUDE_INJECTTWRP), true)
+    TWRP_REQUIRED_MODULES += injecttwrp
+endif
+ifneq ($(TW_EXCLUDE_DEFAULT_USB_INIT), true)
+    TWRP_REQUIRED_MODULES += init.recovery.usb.rc
+endif
+ifeq ($(TWRP_INCLUDE_LOGCAT), true)
+    TWRP_REQUIRED_MODULES += logcat event-log-tags
+    ifeq ($(TARGET_USES_LOGD), true)
+        TWRP_REQUIRED_MODULES += logd libsysutils libnl init.recovery.logd.rc
+    endif
+endif
+# Allow devices to specify device-specific recovery dependencies
+ifneq ($(TARGET_RECOVERY_DEVICE_MODULES),)
+    TWRP_REQUIRED_MODULES += $(TARGET_RECOVERY_DEVICE_MODULES)
+endif
+ifeq ($(TW_INCLUDE_NTFS_3G),true)
+    TWRP_REQUIRED_MODULES += \
+        mount.ntfs \
+        fsck.ntfs \
+        mkfs.ntfs
+endif
+ifeq ($(TARGET_USERIMAGES_USE_F2FS), true)
+    TWRP_REQUIRED_MODULES += sload_f2fs \
+        libfs_mgr \
+        fs_mgr \
+        libinit
+endif
+ifneq ($(TW_LOAD_VENDOR_MODULES),)
+    TWRP_REQUIRED_MODULES += libmodprobe
+endif
+
+TWRP_REQUIRED_MODULES += file_contexts_text
+
+ifeq ($(BOARD_CACHEIMAGE_PARTITION_SIZE),)
+    TWRP_REQUIRED_MODULES += recovery-persist recovery-refresh
+endif
+
+LOCAL_REQUIRED_MODULES += $(TWRP_REQUIRED_MODULES)
+
+TW_THEME_VERSION := $(shell grep TW_THEME_VERSION bootable/recovery/variables.h | cut -d ' ' -f 3)
+
+LOCAL_POST_INSTALL_CMD += \
+    sed -i "s/{themeversion}/$(TW_THEME_VERSION)/" $(TARGET_RECOVERY_ROOT_OUT)/twres/splash.xml; \
+    sed -i "s/{themeversion}/$(TW_THEME_VERSION)/" $(TARGET_RECOVERY_ROOT_OUT)/twres/ui.xml;
+
+include $(BUILD_EXECUTABLE)
+
+# Symlink for file_contexts
+include $(CLEAR_VARS)
+
+LOCAL_MODULE := file_contexts_text
+LOCAL_MODULE_TAGS := optional
+LOCAL_REQUIRED_MODULES := file_contexts.bin
+
+LOCAL_POST_INSTALL_CMD := \
+    $(hide) cp -f $(PRODUCT_OUT)/obj/ETC/file_contexts.bin_intermediates/file_contexts.concat.tmp $(TARGET_RECOVERY_ROOT_OUT)/file_contexts
+
+include $(BUILD_PHONY_PACKAGE)
+
+# recovery-persist (system partition dynamic executable run after /data mounts)
+# ===============================
+include $(CLEAR_VARS)
+LOCAL_SRC_FILES := \
+    recovery-persist.cpp 
+LOCAL_MODULE := recovery-persist
+LOCAL_SHARED_LIBRARIES := liblog libbase 
+LOCAL_STATIC_LIBRARIES := libotautil librecovery_utils
+LOCAL_C_INCLUDES += $(LOCAL_PATH)/otautil/include
+LOCAL_C_INCLUDES += system/core/libstats/include
+LOCAL_C_INCLUDES += $(LOCAL_PATH)/recovery_utils/include
+LOCAL_CFLAGS := -Werror
+LOCAL_INIT_RC := recovery-persist.rc
+include $(BUILD_EXECUTABLE)
+
+# recovery-refresh (system partition dynamic executable run at init)
+# ===============================
+include $(CLEAR_VARS)
+LOCAL_SRC_FILES := \
+    recovery-refresh.cpp
+LOCAL_MODULE := recovery-refresh
+LOCAL_SHARED_LIBRARIES := liblog libbase
+LOCAL_STATIC_LIBRARIES := libotautil librecovery_utils
+LOCAL_C_INCLUDES += $(LOCAL_PATH)/otautil/include
+LOCAL_C_INCLUDES += $(LOCAL_PATH)/recovery_utils/include
+LOCAL_CFLAGS := -Werror
+LOCAL_INIT_RC := recovery-refresh.rc
+include $(BUILD_EXECUTABLE)
+
+# libmounts (static library)
+# ===============================
+include $(CLEAR_VARS)
+LOCAL_SRC_FILES := mounts.cpp
+LOCAL_CFLAGS := \
+    -Wall \
+    -Werror
+LOCAL_MODULE := libmounts
+LOCAL_STATIC_LIBRARIES := libbase
+include $(BUILD_STATIC_LIBRARY)
+
+# librecovery (static library)
+# ===============================
+include $(CLEAR_VARS)
+LOCAL_SRC_FILES := \
+    install.cpp
+LOCAL_CFLAGS := -Wall -Werror
+LOCAL_CFLAGS += -DRECOVERY_API_VERSION=$(RECOVERY_API_VERSION)
+
+ifeq ($(AB_OTA_UPDATER),true)
+    LOCAL_CFLAGS += -DAB_OTA_UPDATER=1
+endif
+
+LOCAL_MODULE := librecovery
+LOCAL_STATIC_LIBRARIES := \
+    libminui \
+    libotautil \
+    libvintf \
+    libcrypto_utils \
+    libcrypto \
+    libbase \
+    libziparchive \
+
+include $(BUILD_STATIC_LIBRARY)
+
+commands_recovery_local_path := $(LOCAL_PATH)
+
+include \
+    $(commands_TWRP_local_path)/updater/Android.mk
+
+include $(commands_TWRP_local_path)/mtp/ffs/Android.mk \
+    $(commands_TWRP_local_path)/minui/Android.mk
+
+#includes for TWRP
+include $(commands_TWRP_local_path)/injecttwrp/Android.mk \
+    $(commands_TWRP_local_path)/htcdumlock/Android.mk \
+    $(commands_TWRP_local_path)/mmcutils/Android.mk \
+    $(commands_TWRP_local_path)/bmlutils/Android.mk \
+    $(commands_TWRP_local_path)/prebuilt/Android.mk \
+    $(commands_TWRP_local_path)/mtdutils/Android.mk \
+    $(commands_TWRP_local_path)/flashutils/Android.mk \
+    $(commands_TWRP_local_path)/pigz/Android.mk \
+    $(commands_TWRP_local_path)/libtar/Android.mk \
+    $(commands_TWRP_local_path)/libcrecovery/Android.mk \
+    $(commands_TWRP_local_path)/libblkid/Android.mk \
+    $(commands_TWRP_local_path)/openaes/Android.mk \
+    $(commands_TWRP_local_path)/twrpTarMain/Android.mk \
+    $(commands_TWRP_local_path)/minzip/Android.mk \
+    $(commands_TWRP_local_path)/dosfstools/Android.mk \
+    $(commands_TWRP_local_path)/etc/Android.mk \
+    $(commands_TWRP_local_path)/simg2img/Android.mk \
+    $(commands_TWRP_local_path)/adbbu/Android.mk \
+    $(commands_TWRP_local_path)/twrpDigest/Android.mk \
+    $(commands_TWRP_local_path)/attr/Android.mk
+
+ifneq ($(TW_OZIP_DECRYPT_KEY),)
+    TWRP_REQUIRED_MODULES += ozip_decrypt
+    include $(commands_TWRP_local_path)/ozip_decrypt/Android.mk
+endif
+
+ifeq ($(TW_INCLUDE_CRYPTO), true)
+    include $(commands_TWRP_local_path)/crypto/fde/Android.mk
+    include $(commands_TWRP_local_path)/crypto/scrypt/Android.mk
+    ifeq ($(TW_INCLUDE_CRYPTO_FBE), true)
+        include $(commands_TWRP_local_path)/crypto/fscrypt/Android.mk
+    endif
+    ifneq ($(TW_CRYPTO_USE_SYSTEM_VOLD),)
+    ifneq ($(TW_CRYPTO_USE_SYSTEM_VOLD),false)
+        include $(commands_TWRP_local_path)/crypto/vold_decrypt/Android.mk
+    endif
+    endif
+    include $(commands_TWRP_local_path)/gpt/Android.mk
+endif
+ifeq ($(BUILD_ID), GINGERBREAD)
+    TW_NO_EXFAT := true
+endif
+ifneq ($(TW_NO_EXFAT), true)
+    include $(commands_TWRP_local_path)/exfat/mkfs/Android.mk \
+            $(commands_TWRP_local_path)/exfat/fsck/Android.mk \
+            $(commands_TWRP_local_path)/fuse/Android.mk \
+            $(commands_TWRP_local_path)/exfat/libexfat/Android.mk
+    ifneq ($(TW_NO_EXFAT_FUSE), true)
+        include $(commands_TWRP_local_path)/exfat/fuse/Android.mk
+    endif
+endif
+ifneq ($(TW_OEM_BUILD),true)
+    include $(commands_TWRP_local_path)/orscmd/Android.mk
+endif
+
+# FB2PNG
+ifeq ($(TW_INCLUDE_FB2PNG), true)
+    include $(commands_TWRP_local_path)/fb2png/Android.mk
+endif
+
+endif
+
+commands_TWRP_local_path :=
diff --git a/data.cpp b/data.cpp
index 5bb9309095..977af3d200 100755
--- a/data.cpp
+++ b/data.cpp
@@ -750,6 +750,8 @@ void DataManager::SetDefaultValues()
 	mData.SetValue(TW_BACKUP_NAME, "(Auto Generate)");
 
 	mConst.SetValue(TW_CLOCK_POS, TW_CLOCK_POS_X);
+	mConst.SetValue(TW_STATUSBAR_INDENT_RIGHT, TW_STATUSBAR_PADDING_RIGHT);
+	mConst.SetValue(TW_STATUSBAR_INDENT_LEFT, TW_STATUSBAR_PADDING_LEFT);
 
 	mPersist.SetValue(TW_INSTALL_REBOOT_VAR, "0");
 	mPersist.SetValue(TW_SIGNED_ZIP_VERIFY_VAR, "0");
diff --git a/data.cpp.orig b/data.cpp.orig
new file mode 100755
index 0000000000..5bb9309095
--- /dev/null
+++ b/data.cpp.orig
@@ -0,0 +1,1193 @@
+/*
+	Copyright 2012 to 2021 TeamWin
+	This file is part of TWRP/TeamWin Recovery Project.
+
+	TWRP is free software: you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation, either version 3 of the License, or
+	(at your option) any later version.
+
+	TWRP is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License
+	along with TWRP.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#include <pthread.h>
+#include <time.h>
+#include <string>
+#include <sstream>
+#include <fstream>
+#include <cctype>
+#include <cutils/properties.h>
+#include <unistd.h>
+
+#include "variables.h"
+#include "data.hpp"
+#include "partitions.hpp"
+#include "twrp-functions.hpp"
+#ifndef TW_NO_SCREEN_TIMEOUT
+#include "gui/blanktimer.hpp"
+#endif
+#include "find_file.hpp"
+#include "set_metadata.h"
+#include "gui/gui.hpp"
+#include "infomanager.hpp"
+
+#define DEVID_MAX 64
+#define HWID_MAX 32
+
+extern "C"
+{
+	#include "twcommon.h"
+	#include "gui/pages.h"
+	void gui_notifyVarChange(const char *name, const char* value);
+}
+#include "minuitwrp/minui.h"
+
+#define FILE_VERSION 0x00010010 // Do not set to 0
+
+using namespace std;
+
+string                                  DataManager::mBackingFile;
+int                                     DataManager::mInitialized = 0;
+InfoManager                             DataManager::mPersist;  // Data that that is not constant and will be saved to the settings file
+InfoManager                             DataManager::mData;     // Data that is not constant and will not be saved to settings file
+InfoManager                             DataManager::mConst;    // Data that is constant and will not be saved to settings file
+
+extern bool datamedia;
+
+#ifndef PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP
+pthread_mutex_t DataManager::m_valuesLock = PTHREAD_RECURSIVE_MUTEX_INITIALIZER;
+#else
+pthread_mutex_t DataManager::m_valuesLock = PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP;
+#endif
+
+// Device ID functions
+void DataManager::sanitize_device_id(char* device_id) {
+	const char* whitelist ="-._";
+	char str[DEVID_MAX];
+	char* c = str;
+
+	snprintf(str, DEVID_MAX, "%s", device_id);
+	memset(device_id, 0, strlen(device_id));
+	while (*c) {
+		if (isalnum(*c) || strchr(whitelist, *c))
+			strncat(device_id, c, 1);
+		c++;
+	}
+	return;
+}
+
+#define CMDLINE_SERIALNO		"androidboot.serialno="
+#define CMDLINE_SERIALNO_LEN	(strlen(CMDLINE_SERIALNO))
+#define CPUINFO_SERIALNO		"Serial"
+#define CPUINFO_SERIALNO_LEN	(strlen(CPUINFO_SERIALNO))
+#define CPUINFO_HARDWARE		"Hardware"
+#define CPUINFO_HARDWARE_LEN	(strlen(CPUINFO_HARDWARE))
+
+void DataManager::get_device_id(void) {
+	FILE *fp;
+	char line[2048];
+	char hardware_id[HWID_MAX] = { 0 };
+	char device_id[DEVID_MAX] = { 0 };
+	char* token;
+
+#ifdef TW_USE_MODEL_HARDWARE_ID_FOR_DEVICE_ID
+	// Use (product_model)_(hardware_id) as device id
+	char model_id[PROPERTY_VALUE_MAX];
+	property_get("ro.product.model", model_id, "error");
+	if (strcmp(model_id, "error") != 0) {
+		LOGINFO("=> product model: '%s'\n", model_id);
+		// Replace spaces with underscores
+		for (size_t i = 0; i < strlen(model_id); i++) {
+			if (model_id[i] == ' ')
+				model_id[i] = '_';
+		}
+		snprintf(device_id, DEVID_MAX, "%s", model_id);
+
+		if (strlen(device_id) < DEVID_MAX) {
+			fp = fopen("proc_cpuinfo.txt", "rt");
+			if (fp != NULL) {
+				while (fgets(line, sizeof(line), fp) != NULL) {
+					if (memcmp(line, CPUINFO_HARDWARE,
+							CPUINFO_HARDWARE_LEN) == 0) {
+						// skip past "Hardware", spaces, and colon
+						token = line + CPUINFO_HARDWARE_LEN;
+						while (*token && (!isgraph(*token) || *token == ':'))
+							token++;
+
+						if (*token && *token != '\n'
+								&& strcmp("UNKNOWN\n", token)) {
+							snprintf(hardware_id, HWID_MAX, "%s", token);
+							if (hardware_id[strlen(hardware_id)-1] == '\n')
+								hardware_id[strlen(hardware_id)-1] = 0;
+							LOGINFO("=> hardware id from cpuinfo: '%s'\n",
+									hardware_id);
+						}
+						break;
+					}
+				}
+				fclose(fp);
+			}
+		}
+
+		if (hardware_id[0] != 0)
+			snprintf(device_id, DEVID_MAX, "%s_%s", model_id, hardware_id);
+
+		sanitize_device_id(device_id);
+		mConst.SetValue("device_id", device_id);
+		LOGINFO("=> using device id: '%s'\n", device_id);
+		return;
+	}
+#endif
+
+#ifndef TW_FORCE_CPUINFO_FOR_DEVICE_ID
+#ifdef TW_USE_SERIALNO_PROPERTY_FOR_DEVICE_ID
+	// Check serial number system property
+	if (property_get("ro.serialno", line, "")) {
+		snprintf(device_id, DEVID_MAX, "%s", line);
+		sanitize_device_id(device_id);
+		mConst.SetValue("device_id", device_id);
+		return;
+	}
+#endif
+
+	// Check the cmdline to see if the serial number was supplied
+	fp = fopen("/proc/cmdline", "rt");
+	if (fp != NULL) {
+		fgets(line, sizeof(line), fp);
+		fclose(fp); // cmdline is only one line long
+
+		token = strtok(line, " ");
+		while (token) {
+			if (memcmp(token, CMDLINE_SERIALNO, CMDLINE_SERIALNO_LEN) == 0) {
+				token += CMDLINE_SERIALNO_LEN;
+				snprintf(device_id, DEVID_MAX, "%s", token);
+				sanitize_device_id(device_id); // also removes newlines
+				mConst.SetValue("device_id", device_id);
+				return;
+			}
+			token = strtok(NULL, " ");
+		}
+	}
+#endif
+	// Check cpuinfo for serial number; if found, use as device_id
+	// If serial number is not found, fallback to hardware_id for the device_id
+	fp = fopen("/proc/cpuinfo", "rt");
+	if (fp != NULL) {
+		while (fgets(line, sizeof(line), fp) != NULL) {
+			if (memcmp(line, CPUINFO_SERIALNO, CPUINFO_SERIALNO_LEN) == 0) {
+				// skip past "Serial", spaces, and colon
+				token = line + CPUINFO_SERIALNO_LEN;
+				while (*token && (!isgraph(*token) || *token == ':'))
+					token++;
+
+				if (*token && *token != '\n') {
+					snprintf(device_id, DEVID_MAX, "%s", token);
+					sanitize_device_id(device_id); // also removes newlines
+					LOGINFO("=> serial from cpuinfo: '%s'\n", device_id);
+					mConst.SetValue("device_id", device_id);
+					fclose(fp);
+					return;
+				}
+			} else if (memcmp(line, CPUINFO_HARDWARE,
+					CPUINFO_HARDWARE_LEN) == 0) {
+				// skip past "Hardware", spaces, and colon
+				token = line + CPUINFO_HARDWARE_LEN;
+				while (*token && (!isgraph(*token) || *token == ':'))
+					token++;
+
+				if (*token && *token != '\n') {
+					snprintf(hardware_id, HWID_MAX, "%s", token);
+					if (hardware_id[strlen(hardware_id)-1] == '\n')
+						hardware_id[strlen(hardware_id)-1] = 0;
+					LOGINFO("=> hardware id from cpuinfo: '%s'\n", hardware_id);
+				}
+			}
+		}
+		fclose(fp);
+	}
+
+	if (hardware_id[0] != 0) {
+		LOGINFO("\nusing hardware id for device id: '%s'\n", hardware_id);
+		snprintf(device_id, DEVID_MAX, "%s", hardware_id);
+		sanitize_device_id(device_id);
+		mConst.SetValue("device_id", device_id);
+		return;
+	}
+
+	strcpy(device_id, "serialno");
+	LOGINFO("=> device id not found, using '%s'\n", device_id);
+	mConst.SetValue("device_id", device_id);
+	return;
+}
+
+int DataManager::ResetDefaults()
+{
+	pthread_mutex_lock(&m_valuesLock);
+	mPersist.Clear();
+	mData.Clear();
+	mConst.Clear();
+	pthread_mutex_unlock(&m_valuesLock);
+
+	SetDefaultValues();
+	return 0;
+}
+
+int DataManager::LoadValues(const string& filename)
+{
+	string dev_id;
+
+	if (!mInitialized)
+		SetDefaultValues();
+
+	GetValue("device_id", dev_id);
+	// Save off the backing file for set operations
+	mBackingFile = filename;
+	mPersist.SetFile(filename);
+	mPersist.SetFileVersion(FILE_VERSION);
+
+	// Read in the file, if possible
+	pthread_mutex_lock(&m_valuesLock);
+	mPersist.LoadValues();
+
+#ifndef TW_NO_SCREEN_TIMEOUT
+	blankTimer.setTime(mPersist.GetIntValue("tw_screen_timeout_secs"));
+#endif
+
+	pthread_mutex_unlock(&m_valuesLock);
+	string current = GetCurrentStoragePath();
+	TWPartition* Part = PartitionManager.Find_Partition_By_Path(current);
+	if (!Part)
+		Part = PartitionManager.Get_Default_Storage_Partition();
+	if (Part && current != Part->Storage_Path && Part->Mount(false)) {
+		LOGINFO("LoadValues setting storage path to '%s'\n", Part->Storage_Path.c_str());
+		SetValue("tw_storage_path", Part->Storage_Path);
+	} else {
+		SetBackupFolder();
+	}
+	return 0;
+}
+
+int DataManager::Flush()
+{
+	return SaveValues();
+}
+
+int DataManager::SaveValues()
+{
+#ifndef TW_OEM_BUILD
+	if (mBackingFile.empty())
+		return -1;
+
+	string mount_path = GetSettingsStoragePath();
+	PartitionManager.Mount_By_Path(mount_path.c_str(), 1);
+
+	mPersist.SetFile(mBackingFile);
+	mPersist.SetFileVersion(FILE_VERSION);
+	pthread_mutex_lock(&m_valuesLock);
+	mPersist.SaveValues();
+	pthread_mutex_unlock(&m_valuesLock);
+
+	tw_set_default_metadata(mBackingFile.c_str());
+	LOGINFO("Saved settings file values to '%s'\n", mBackingFile.c_str());
+#endif // ifdef TW_OEM_BUILD
+	return 0;
+}
+
+int DataManager::GetValue(const string& varName, string& value)
+{
+	string localStr = varName;
+	int ret = 0;
+
+	if (!mInitialized)
+		SetDefaultValues();
+
+	// Strip off leading and trailing '%' if provided
+	if (localStr.length() > 2 && localStr[0] == '%' && localStr[localStr.length()-1] == '%')
+	{
+		localStr.erase(0, 1);
+		localStr.erase(localStr.length() - 1, 1);
+	}
+
+	// Handle magic values
+	if (GetMagicValue(localStr, value) == 0)
+		return 0;
+
+	// Handle property
+	if (localStr.length() > 9 && localStr.substr(0, 9) == "property.") {
+		char property_value[PROPERTY_VALUE_MAX];
+		property_get(localStr.substr(9).c_str(), property_value, "");
+		value = property_value;
+		return 0;
+	}
+
+	pthread_mutex_lock(&m_valuesLock);
+	ret = mConst.GetValue(localStr, value);
+	if (ret == 0)
+		goto exit;
+
+	ret = mPersist.GetValue(localStr, value);
+	if (ret == 0)
+		goto exit;
+
+	ret = mData.GetValue(localStr, value);
+exit:
+	pthread_mutex_unlock(&m_valuesLock);
+	return ret;
+}
+
+int DataManager::GetValue(const string& varName, int& value)
+{
+	string data;
+
+	if (GetValue(varName,data) != 0)
+		return -1;
+
+	value = atoi(data.c_str());
+	return 0;
+}
+
+int DataManager::GetValue(const string& varName, float& value)
+{
+	string data;
+
+	if (GetValue(varName,data) != 0)
+		return -1;
+
+	value = atof(data.c_str());
+	return 0;
+}
+
+int DataManager::GetValue(const string& varName, unsigned long long& value)
+{
+	string data;
+
+	if (GetValue(varName,data) != 0)
+		return -1;
+
+	value = strtoull(data.c_str(), NULL, 10);
+	return 0;
+}
+
+// This function will return an empty string if the value doesn't exist
+string DataManager::GetStrValue(const string& varName)
+{
+	string retVal;
+
+	GetValue(varName, retVal);
+	return retVal;
+}
+
+// This function will return 0 if the value doesn't exist
+int DataManager::GetIntValue(const string& varName)
+{
+	string retVal;
+
+	GetValue(varName, retVal);
+	return atoi(retVal.c_str());
+}
+
+int DataManager::SetValue(const string& varName, const string& value, const int persist /* = 0 */)
+{
+	if (!mInitialized)
+		SetDefaultValues();
+
+	// Handle property
+	if (varName.length() > 9 && varName.substr(0, 9) == "property.") {
+		int ret = property_set(varName.substr(9).c_str(), value.c_str());
+		if (ret)
+			LOGERR("Error setting property '%s' to '%s'\n", varName.substr(9).c_str(), value.c_str());
+		return ret;
+	}
+
+	// Don't allow empty values or numerical starting values
+	if (varName.empty() || (varName[0] >= '0' && varName[0] <= '9'))
+		return -1;
+
+	string test;
+	pthread_mutex_lock(&m_valuesLock);
+	int constChk = mConst.GetValue(varName, test);
+	if (constChk == 0) {
+		pthread_mutex_unlock(&m_valuesLock);
+		return -1;
+	}
+
+	if (persist) {
+		mPersist.SetValue(varName, value);
+	} else {
+		int persistChk = mPersist.GetValue(varName, test);
+		if (persistChk == 0) {
+			mPersist.SetValue(varName, value);
+		} else {
+			mData.SetValue(varName, value);
+		}
+	}
+
+	pthread_mutex_unlock(&m_valuesLock);
+
+#ifndef TW_NO_SCREEN_TIMEOUT
+	if (varName == "tw_screen_timeout_secs") {
+		blankTimer.setTime(atoi(value.c_str()));
+	} else
+#endif
+	if (varName == "tw_storage_path") {
+		SetBackupFolder();
+	}
+	gui_notifyVarChange(varName.c_str(), value.c_str());
+	return 0;
+}
+
+int DataManager::SetValue(const string& varName, const int value, const int persist /* = 0 */)
+{
+	ostringstream valStr;
+	valStr << value;
+	return SetValue(varName, valStr.str(), persist);
+}
+
+int DataManager::SetValue(const string& varName, const float value, const int persist /* = 0 */)
+{
+	ostringstream valStr;
+	valStr << value;
+	return SetValue(varName, valStr.str(), persist);;
+}
+
+int DataManager::SetValue(const string& varName, const unsigned long long& value, const int persist /* = 0 */)
+{
+	ostringstream valStr;
+	valStr << value;
+	return SetValue(varName, valStr.str(), persist);
+}
+
+// For legacy code that doesn't set a scope
+int DataManager::SetProgress(const float Fraction) {
+	if (SetValue("ui_portion_size", 0) != 0)
+		return -1;
+	if (SetValue("ui_portion_start", 0) != 0)
+		return -1;
+	ShowProgress(1, 0);
+	int res = _SetProgress(Fraction);
+	if (SetValue("ui_portion_size", 0) != 0)
+		return -1;
+	if (SetValue("ui_portion_start", 0) != 0)
+		return -1;
+	return res;
+}
+
+int DataManager::_SetProgress(float Fraction) {
+	float Portion_Start, Portion_Size;
+	GetValue("ui_portion_size", Portion_Size);
+	GetValue("ui_portion_start", Portion_Start);
+	//LOGINFO("SetProgress(%.2lf): Portion_Size: %.2lf Portion_Start: %.2lf\n", Fraction, Portion_Size, Portion_Start);
+	if (Fraction < 0.0)
+		Fraction = 0;
+	if (Fraction > 1.0)
+		Fraction = 1;
+	if (SetValue("ui_progress", (float) ((Portion_Start + (Portion_Size * Fraction)) * 100.0)) != 0)
+		return -1;
+	return (SetValue("ui_progress_portion", 0) != 0);
+}
+
+int DataManager::ShowProgress(float Portion, const float Seconds)
+{
+	float Portion_Start, Portion_Size;
+	GetValue("ui_portion_size", Portion_Size);
+	GetValue("ui_portion_start", Portion_Start);
+	Portion_Start += Portion_Size;
+	if(Portion + Portion_Start > 1.0)
+		Portion = 1.0 - Portion_Start;
+	//LOGINFO("ShowProgress(%.2lf, %.2lf): Portion_Start: %.2lf\n", Portion, Seconds, Portion_Start);
+	if (SetValue("ui_portion_start", Portion_Start) != 0)
+		return -1;
+	if (SetValue("ui_portion_size", Portion) != 0)
+		return -1;
+	if (SetValue("ui_progress", (float)(Portion_Start * 100.0)) != 0)
+		return -1;
+	if(Seconds) {
+		if (SetValue("ui_progress_portion", (float)((Portion * 100.0) + Portion_Start)) != 0)
+			return -1;
+		if (SetValue("ui_progress_frames", Seconds * 48) != 0)
+			return -1;
+	}
+	return 0;
+}
+
+void DataManager::update_tz_environment_variables(void)
+{
+	setenv("TZ", GetStrValue(TW_TIME_ZONE_VAR).c_str(), 1);
+	tzset();
+}
+
+void DataManager::SetBackupFolder()
+{
+	string str = GetCurrentStoragePath();
+	TWPartition* partition = PartitionManager.Find_Partition_By_Path(str);
+	str += TWFunc::Check_For_TwrpFolder() + "/BACKUPS/";
+
+	string dev_id;
+	GetValue("device_id", dev_id);
+
+	str += dev_id;
+	LOGINFO("Backup folder set to '%s'\n", str.c_str());
+	SetValue(TW_BACKUPS_FOLDER_VAR, str, 0);
+	if (partition != NULL) {
+		SetValue("tw_storage_display_name", partition->Storage_Name);
+		char free_space[255];
+		sprintf(free_space, "%llu", partition->Free / 1024 / 1024);
+		SetValue("tw_storage_free_size", free_space);
+		string zip_path, zip_root, storage_path;
+		GetValue(TW_ZIP_LOCATION_VAR, zip_path);
+		if (partition->Has_Data_Media && !partition->Symlink_Mount_Point.empty())
+			storage_path = partition->Symlink_Mount_Point;
+		else
+			storage_path = partition->Storage_Path;
+		if (zip_path.size() < storage_path.size()) {
+			SetValue(TW_ZIP_LOCATION_VAR, storage_path);
+		} else {
+			zip_root = TWFunc::Get_Root_Path(zip_path);
+			if (zip_root != storage_path) {
+				LOGINFO("DataManager::SetBackupFolder zip path was %s changing to %s, %s\n", zip_path.c_str(), storage_path.c_str(), zip_root.c_str());
+				SetValue(TW_ZIP_LOCATION_VAR, storage_path);
+			}
+		}
+	} else {
+		if (PartitionManager.Fstab_Processed() != 0) {
+			LOGINFO("Storage partition '%s' not found\n", str.c_str());
+			gui_err("unable_locate_storage=Unable to locate storage device.");
+		}
+	}
+}
+
+void DataManager::SetDefaultValues()
+{
+	string str, path;
+
+	mConst.SetConst();
+
+	get_device_id();
+
+	pthread_mutex_lock(&m_valuesLock);
+
+	mInitialized = 1;
+
+	mConst.SetValue("true", "1");
+	mConst.SetValue("false", "0");
+
+	mConst.SetValue(TW_VERSION_VAR, TW_VERSION_STR);
+
+#ifndef TW_NO_HAPTICS
+	mPersist.SetValue("tw_button_vibrate", "80");
+	mPersist.SetValue("tw_keyboard_vibrate", "40");
+	mPersist.SetValue("tw_action_vibrate", "160");
+	mConst.SetValue("tw_disable_haptics", "0");
+#else
+	LOGINFO("TW_NO_HAPTICS := true\n");
+	mConst.SetValue("tw_disable_haptics", "1");
+#endif
+
+	TWPartition *store = PartitionManager.Get_Default_Storage_Partition();
+	if (store)
+		mPersist.SetValue("tw_storage_path", store->Storage_Path);
+	else
+		mPersist.SetValue("tw_storage_path", "/");
+
+#ifdef TW_FORCE_CPUINFO_FOR_DEVICE_ID
+	printf("TW_FORCE_CPUINFO_FOR_DEVICE_ID := true\n");
+#endif
+
+#ifdef BOARD_HAS_NO_REAL_SDCARD
+	printf("BOARD_HAS_NO_REAL_SDCARD := true\n");
+	mConst.SetValue(TW_ALLOW_PARTITION_SDCARD, "0");
+#else
+	mConst.SetValue(TW_ALLOW_PARTITION_SDCARD, "1");
+#endif
+
+#ifdef TW_INCLUDE_DUMLOCK
+	printf("TW_INCLUDE_DUMLOCK := true\n");
+	mConst.SetValue(TW_SHOW_DUMLOCK, "1");
+#else
+	mConst.SetValue(TW_SHOW_DUMLOCK, "0");
+#endif
+
+	mData.SetValue(TW_RECOVERY_FOLDER_VAR, TW_DEFAULT_RECOVERY_FOLDER);
+
+	str = GetCurrentStoragePath();
+	mPersist.SetValue(TW_ZIP_LOCATION_VAR, str);
+	str += DataManager::GetStrValue(TW_RECOVERY_FOLDER_VAR) + "/BACKUPS/";
+
+	string dev_id;
+	mConst.GetValue("device_id", dev_id);
+
+	str += dev_id;
+	mData.SetValue(TW_BACKUPS_FOLDER_VAR, str);
+
+	mConst.SetValue(TW_REBOOT_SYSTEM, "1");
+#ifdef TW_NO_REBOOT_RECOVERY
+	printf("TW_NO_REBOOT_RECOVERY := true\n");
+	mConst.SetValue(TW_REBOOT_RECOVERY, "0");
+#else
+	mConst.SetValue(TW_REBOOT_RECOVERY, "1");
+#endif
+	mConst.SetValue(TW_REBOOT_POWEROFF, "1");
+#ifdef TW_NO_REBOOT_BOOTLOADER
+	printf("TW_NO_REBOOT_BOOTLOADER := true\n");
+	mConst.SetValue(TW_REBOOT_BOOTLOADER, "0");
+#else
+	mConst.SetValue(TW_REBOOT_BOOTLOADER, "1");
+#endif
+#ifdef RECOVERY_SDCARD_ON_DATA
+	printf("RECOVERY_SDCARD_ON_DATA := true\n");
+	mConst.SetValue(TW_HAS_DATA_MEDIA, "1");
+	datamedia = true;
+#else
+	mData.SetValue(TW_HAS_DATA_MEDIA, "0");
+#endif
+#ifdef TW_NO_BATT_PERCENT
+	printf("TW_NO_BATT_PERCENT := true\n");
+	mConst.SetValue(TW_NO_BATTERY_PERCENT, "1");
+#else
+	mConst.SetValue(TW_NO_BATTERY_PERCENT, "0");
+#endif
+#ifdef TW_NO_CPU_TEMP
+	printf("TW_NO_CPU_TEMP := true\n");
+	mConst.SetValue("tw_no_cpu_temp", "1");
+#else
+	string cpu_temp_file;
+#ifdef TW_CUSTOM_CPU_TEMP_PATH
+	cpu_temp_file = EXPAND(TW_CUSTOM_CPU_TEMP_PATH);
+#else
+	cpu_temp_file = "/sys/class/thermal/thermal_zone0/temp";
+#endif
+	if (TWFunc::Path_Exists(cpu_temp_file)) {
+		mConst.SetValue("tw_no_cpu_temp", "0");
+	} else {
+		LOGINFO("CPU temperature file '%s' not found, disabling CPU temp.\n", cpu_temp_file.c_str());
+		mConst.SetValue("tw_no_cpu_temp", "1");
+	}
+#endif
+#ifdef TW_CUSTOM_POWER_BUTTON
+	printf("TW_POWER_BUTTON := %s\n", EXPAND(TW_CUSTOM_POWER_BUTTON));
+	mConst.SetValue(TW_POWER_BUTTON, EXPAND(TW_CUSTOM_POWER_BUTTON));
+#else
+	mConst.SetValue(TW_POWER_BUTTON, "0");
+#endif
+#ifdef TW_ALWAYS_RMRF
+	printf("TW_ALWAYS_RMRF := true\n");
+	mConst.SetValue(TW_RM_RF_VAR, "1");
+#endif
+#ifdef TW_NEVER_UNMOUNT_SYSTEM
+	printf("TW_NEVER_UNMOUNT_SYSTEM := true\n");
+	mConst.SetValue(TW_DONT_UNMOUNT_SYSTEM, "1");
+#else
+	mConst.SetValue(TW_DONT_UNMOUNT_SYSTEM, "0");
+#endif
+#ifdef TW_NO_USB_STORAGE
+	printf("TW_NO_USB_STORAGE := true\n");
+	mConst.SetValue(TW_HAS_USB_STORAGE, "0");
+#else
+	char lun_file[255];
+	string Lun_File_str = CUSTOM_LUN_FILE;
+	size_t found = Lun_File_str.find("%");
+	if (found != string::npos) {
+		sprintf(lun_file, CUSTOM_LUN_FILE, 0);
+		Lun_File_str = lun_file;
+	}
+	if (!TWFunc::Path_Exists(Lun_File_str)) {
+		LOGINFO("Lun file '%s' does not exist, USB storage mode disabled\n", Lun_File_str.c_str());
+		mConst.SetValue(TW_HAS_USB_STORAGE, "0");
+	} else {
+		LOGINFO("Lun file '%s'\n", Lun_File_str.c_str());
+		mData.SetValue(TW_HAS_USB_STORAGE, "1");
+	}
+#endif
+#ifdef TW_INCLUDE_INJECTTWRP
+	printf("TW_INCLUDE_INJECTTWRP := true\n");
+	mConst.SetValue(TW_HAS_INJECTTWRP, "1");
+	mPersist(TW_INJECT_AFTER_ZIP, "1");
+#else
+	mConst.SetValue(TW_HAS_INJECTTWRP, "0");
+#endif
+#ifdef TW_HAS_DOWNLOAD_MODE
+	printf("TW_HAS_DOWNLOAD_MODE := true\n");
+	mConst.SetValue(TW_DOWNLOAD_MODE, "1");
+#endif
+#ifdef TW_HAS_EDL_MODE
+	printf("TW_HAS_EDL_MODE := true\n");
+	mConst.SetValue(TW_EDL_MODE, "1");
+#endif
+#ifdef PRODUCT_USE_DYNAMIC_PARTITIONS
+	printf("PRODUCT_USE_DYNAMIC_PARTITIONS := true\n");
+	mConst.SetValue(TW_FASTBOOT_MODE, "1");
+	mConst.SetValue(TW_IS_SUPER, "1");
+#else
+	mConst.SetValue(TW_IS_SUPER, "0");
+#endif
+#ifdef TW_INCLUDE_CRYPTO
+	mConst.SetValue(TW_HAS_CRYPTO, "1");
+	printf("TW_INCLUDE_CRYPTO := true\n");
+#endif
+#ifdef TW_SDEXT_NO_EXT4
+	printf("TW_SDEXT_NO_EXT4 := true\n");
+	mConst.SetValue(TW_SDEXT_DISABLE_EXT4, "1");
+#else
+	mConst.SetValue(TW_SDEXT_DISABLE_EXT4, "0");
+#endif
+
+#ifdef TW_HAS_NO_BOOT_PARTITION
+	mPersist.SetValue("tw_backup_list", "/system;/data;");
+#else
+#ifdef PRODUCT_USE_DYNAMIC_PARTITIONS
+	mPersist.SetValue("tw_backup_list", "/data;");
+#else
+	mPersist.SetValue("tw_backup_list", "/system;/data;/boot;");
+#endif
+#endif
+	mConst.SetValue(TW_MIN_SYSTEM_VAR, TW_MIN_SYSTEM_SIZE);
+	mData.SetValue(TW_BACKUP_NAME, "(Auto Generate)");
+
+	mConst.SetValue(TW_CLOCK_POS, TW_CLOCK_POS_X);
+
+	mPersist.SetValue(TW_INSTALL_REBOOT_VAR, "0");
+	mPersist.SetValue(TW_SIGNED_ZIP_VERIFY_VAR, "0");
+	mPersist.SetValue(TW_DISABLE_FREE_SPACE_VAR, "0");
+	mPersist.SetValue(TW_FORCE_DIGEST_CHECK_VAR, "0");
+	mPersist.SetValue(TW_USE_COMPRESSION_VAR, "0");
+	mPersist.SetValue(TW_TIME_ZONE_VAR, "CST6CDT,M3.2.0,M11.1.0");
+	mPersist.SetValue(TW_GUI_SORT_ORDER, "1");
+	mPersist.SetValue(TW_RM_RF_VAR, "0");
+	mPersist.SetValue(TW_SKIP_DIGEST_CHECK_VAR, "0");
+	mPersist.SetValue(TW_SKIP_DIGEST_CHECK_ZIP_VAR, "1");
+	mPersist.SetValue(TW_SKIP_DIGEST_GENERATE_VAR, "0");
+	mPersist.SetValue(TW_SDEXT_SIZE, "0");
+	mPersist.SetValue(TW_SWAP_SIZE, "0");
+	mPersist.SetValue(TW_SDPART_FILE_SYSTEM, "ext3");
+	mPersist.SetValue(TW_TIME_ZONE_GUISEL, "CST6;CDT,M3.2.0,M11.1.0");
+	mPersist.SetValue(TW_TIME_ZONE_GUIOFFSET, "0");
+	mPersist.SetValue(TW_TIME_ZONE_GUIDST, "1");
+	mPersist.SetValue(TW_AUTO_REFLASHTWRP_VAR, "0");
+
+	mData.SetValue(TW_ACTION_BUSY, "0");
+	mData.SetValue("tw_wipe_cache", "0");
+	mData.SetValue("tw_wipe_dalvik", "0");
+	mData.SetValue(TW_ZIP_INDEX, "0");
+	mData.SetValue(TW_ZIP_QUEUE_COUNT, "0");
+	mData.SetValue(TW_FILENAME, "/sdcard");
+	mData.SetValue(TW_SIMULATE_ACTIONS, "0");
+	mData.SetValue(TW_SIMULATE_FAIL, "0");
+	mData.SetValue(TW_IS_ENCRYPTED, "0");
+	mData.SetValue(TW_IS_DECRYPTED, "0");
+	mData.SetValue(TW_CRYPTO_PASSWORD, "0");
+	mData.SetValue(TW_CRYPTO_PWTYPE, "0"); // Set initial value so that recovery will not be confused when using unencrypted data or failed to decrypt data
+	mData.SetValue("tw_terminal_state", "0");
+	mData.SetValue("tw_background_thread_running", "0");
+	mData.SetValue(TW_RESTORE_FILE_DATE, "0");
+	mPersist.SetValue("tw_military_time", "0");
+
+#ifdef TW_INCLUDE_CRYPTO
+	mPersist.SetValue(TW_USE_SHA2, "1");
+	mPersist.SetValue(TW_NO_SHA2, "0");
+#else
+	mPersist.SetValue(TW_NO_SHA2, "1");
+#endif
+#ifdef AB_OTA_UPDATER
+	mPersist.SetValue(TW_UNMOUNT_SYSTEM, "0");
+#else
+	mPersist.SetValue(TW_UNMOUNT_SYSTEM, "1");
+#endif
+#if defined BOARD_USES_RECOVERY_AS_BOOT && defined BOARD_BUILD_SYSTEM_ROOT_IMAGE
+	mConst.SetValue("tw_uses_initramfs", "1");
+#else
+	mConst.SetValue("tw_uses_initramfs", "0");
+#endif
+#ifdef TW_NO_SCREEN_TIMEOUT
+	mConst.SetValue("tw_screen_timeout_secs", "0");
+	mConst.SetValue("tw_no_screen_timeout", "1");
+#else
+	mPersist.SetValue("tw_screen_timeout_secs", "60");
+	mPersist.SetValue("tw_no_screen_timeout", "0");
+#endif
+	mData.SetValue("tw_gui_done", "0");
+	mData.SetValue("tw_encrypt_backup", "0");
+	mData.SetValue("tw_sleep_total", "5");
+	mData.SetValue("tw_sleep", "5");
+	mData.SetValue("tw_enable_fastboot", "0");
+
+
+	if (android::base::GetBoolProperty("ro.virtual_ab.enabled", false))
+		mConst.SetValue("tw_virtual_ab.enabled", "1");
+	else
+		mConst.SetValue("tw_virtual_ab.enabled", "0");
+	// Brightness handling
+	string findbright;
+#ifdef TW_BRIGHTNESS_PATH
+	findbright = EXPAND(TW_BRIGHTNESS_PATH);
+	LOGINFO("TW_BRIGHTNESS_PATH := %s\n", findbright.c_str());
+	if (!TWFunc::Path_Exists(findbright)) {
+		LOGINFO("Specified brightness file '%s' not found.\n", findbright.c_str());
+		findbright = "";
+	}
+#endif
+	if (findbright.empty()) {
+		// Attempt to locate the brightness file
+		findbright = Find_File::Find("brightness", "/sys/class/backlight");
+		if (findbright.empty()) findbright = Find_File::Find("brightness", "/sys/class/leds/lcd-backlight");
+	}
+	if (findbright.empty()) {
+		LOGINFO("Unable to locate brightness file\n");
+		mConst.SetValue("tw_has_brightnesss_file", "0");
+	} else {
+		LOGINFO("Found brightness file at '%s'\n", findbright.c_str());
+		mConst.SetValue("tw_has_brightnesss_file", "1");
+		mConst.SetValue("tw_brightness_file", findbright);
+		string maxBrightness;
+#ifdef TW_MAX_BRIGHTNESS
+		ostringstream maxVal;
+		maxVal << TW_MAX_BRIGHTNESS;
+		maxBrightness = maxVal.str();
+#else
+		// Attempt to locate the max_brightness file
+		string maxbrightpath = findbright.insert(findbright.rfind('/') + 1, "max_");
+		if (TWFunc::Path_Exists(maxbrightpath)) {
+			ifstream maxVal(maxbrightpath.c_str());
+			if (maxVal >> maxBrightness) {
+				LOGINFO("Got max brightness %s from '%s'\n", maxBrightness.c_str(), maxbrightpath.c_str());
+			} else {
+				// Something went wrong, set that to indicate error
+				maxBrightness = "-1";
+			}
+		}
+		if (atoi(maxBrightness.c_str()) <= 0)
+		{
+			// Fallback into default
+			ostringstream maxVal;
+			maxVal << 255;
+			maxBrightness = maxVal.str();
+		}
+#endif
+		mConst.SetValue("tw_brightness_max", maxBrightness);
+		mPersist.SetValue("tw_brightness", maxBrightness);
+		mPersist.SetValue("tw_brightness_pct", "100");
+#ifdef TW_SECONDARY_BRIGHTNESS_PATH
+		string secondfindbright = EXPAND(TW_SECONDARY_BRIGHTNESS_PATH);
+		if (secondfindbright != "" && TWFunc::Path_Exists(secondfindbright)) {
+			LOGINFO("Will use a second brightness file at '%s'\n", secondfindbright.c_str());
+			mConst.SetValue("tw_secondary_brightness_file", secondfindbright);
+		} else {
+			LOGINFO("Specified secondary brightness file '%s' not found.\n", secondfindbright.c_str());
+		}
+#endif
+#ifdef TW_DEFAULT_BRIGHTNESS
+		int defValInt = TW_DEFAULT_BRIGHTNESS;
+		int maxValInt = atoi(maxBrightness.c_str());
+		// Deliberately int so the % is always a whole number
+		int defPctInt = ( ( (double)defValInt / maxValInt ) * 100 );
+		ostringstream defPct;
+		defPct << defPctInt;
+		mPersist.SetValue("tw_brightness_pct", defPct.str());
+
+		ostringstream defVal;
+		defVal << TW_DEFAULT_BRIGHTNESS;
+		mPersist.SetValue("tw_brightness", defVal.str());
+		TWFunc::Set_Brightness(defVal.str());
+#else
+		TWFunc::Set_Brightness(maxBrightness);
+#endif
+	}
+
+#ifndef TW_EXCLUDE_ENCRYPTED_BACKUPS
+	mConst.SetValue("tw_include_encrypted_backup", "1");
+#else
+	LOGINFO("TW_EXCLUDE_ENCRYPTED_BACKUPS := true\n");
+	mConst.SetValue("tw_include_encrypted_backup", "0");
+#endif
+#ifdef TW_HAS_MTP
+	mConst.SetValue("tw_has_mtp", "1");
+	mPersist.SetValue("tw_mtp_enabled", "1");
+	mPersist.SetValue("tw_mtp_debug", "0");
+#else
+	LOGINFO("TW_EXCLUDE_MTP := true\n");
+	mConst.SetValue("tw_has_mtp", "0");
+	mConst.SetValue("tw_mtp_enabled", "0");
+#endif
+	mPersist.SetValue("tw_mount_system_ro", "2");
+	mPersist.SetValue("tw_never_show_system_ro_page", "0");
+	mPersist.SetValue("tw_language", EXPAND(TW_DEFAULT_LANGUAGE));
+	LOGINFO("LANG: %s\n", EXPAND(TW_DEFAULT_LANGUAGE));
+
+	mData.SetValue("tw_has_adopted_storage", "0");
+
+#ifdef AB_OTA_UPDATER
+	LOGINFO("AB_OTA_UPDATER := true\n");
+	mConst.SetValue("tw_has_boot_slots", "1");
+#else
+	mConst.SetValue("tw_has_boot_slots", "0");
+#endif
+
+#ifdef TW_NO_LEGACY_PROPS
+	LOGINFO("TW_NO_LEGACY_PROPS := true\n");
+#endif
+
+#ifdef TW_OEM_BUILD
+	LOGINFO("TW_OEM_BUILD := true\n");
+	mConst.SetValue("tw_oem_build", "1");
+	mConst.SetValue("tw_app_installed_in_system", "0");
+#else
+	mConst.SetValue("tw_oem_build", "0");
+	mPersist.SetValue("tw_app_prompt", "1");
+	mPersist.SetValue("tw_app_install_system", "1");
+	mData.SetValue("tw_app_install_status", "0"); // 0 = no status, 1 = not installed, 2 = already installed
+	mData.SetValue("tw_app_installed_in_system", "0");
+#endif
+#ifndef TW_EXCLUDE_NANO
+	mConst.SetValue("tw_include_nano", "1");
+#else
+	LOGINFO("TW_EXCLUDE_NANO := true\n");
+	mConst.SetValue("tw_include_nano", "0");
+#endif
+
+	mData.SetValue("tw_flash_both_slots", "0");
+	mData.SetValue("tw_is_slot_part", "0");
+
+	mData.SetValue("tw_enable_adb_backup", "0");
+
+	if (TWFunc::Path_Exists("/system/bin/logcat"))
+		mConst.SetValue("tw_logcat_exists", "1");
+	else
+		mConst.SetValue("tw_logcat_exists", "0");
+
+	if (TWFunc::Path_Exists("/system/bin/magiskboot"))
+		mConst.SetValue("tw_has_repack_tools", "1");
+	else
+		mConst.SetValue("tw_has_repack_tools", "0");
+
+	pthread_mutex_unlock(&m_valuesLock);
+}
+
+// Magic Values
+int DataManager::GetMagicValue(const string& varName, string& value)
+{
+	// Handle special dynamic cases
+	if (varName == "tw_time")
+	{
+		char tmp[32];
+
+		struct tm *current;
+		time_t now;
+		int tw_military_time;
+		now = time(0);
+		current = localtime(&now);
+		GetValue(TW_MILITARY_TIME, tw_military_time);
+		if (current->tm_hour >= 12)
+		{
+			if (tw_military_time == 1)
+				sprintf(tmp, "%d:%02d", current->tm_hour, current->tm_min);
+			else
+				sprintf(tmp, "%d:%02d PM", current->tm_hour == 12 ? 12 : current->tm_hour - 12, current->tm_min);
+		}
+		else
+		{
+			if (tw_military_time == 1)
+				sprintf(tmp, "%d:%02d", current->tm_hour, current->tm_min);
+			else
+				sprintf(tmp, "%d:%02d AM", current->tm_hour == 0 ? 12 : current->tm_hour, current->tm_min);
+		}
+		value = tmp;
+		return 0;
+	}
+	else if (varName == "tw_cpu_temp")
+	{
+		int tw_no_cpu_temp;
+		GetValue("tw_no_cpu_temp", tw_no_cpu_temp);
+		if (tw_no_cpu_temp == 1) return -1;
+
+		string cpu_temp_file;
+		static unsigned long convert_temp = 0;
+		static time_t cpuSecCheck = 0;
+		struct timeval curTime;
+		string results;
+
+		gettimeofday(&curTime, NULL);
+		if (curTime.tv_sec > cpuSecCheck)
+		{
+#ifdef TW_CUSTOM_CPU_TEMP_PATH
+			cpu_temp_file = EXPAND(TW_CUSTOM_CPU_TEMP_PATH);
+			if (TWFunc::read_file(cpu_temp_file, results) != 0)
+				return -1;
+#else
+			cpu_temp_file = "/sys/class/thermal/thermal_zone0/temp";
+			if (TWFunc::read_file(cpu_temp_file, results) != 0)
+				return -1;
+#endif
+			convert_temp = strtoul(results.c_str(), NULL, 0) / 1000;
+			if (convert_temp <= 0)
+				convert_temp = strtoul(results.c_str(), NULL, 0);
+			if (convert_temp >= 150)
+				convert_temp = strtoul(results.c_str(), NULL, 0) / 10;
+			cpuSecCheck = curTime.tv_sec + 5;
+		}
+		value = TWFunc::to_string(convert_temp);
+		return 0;
+	}
+	else if (varName == "tw_battery")
+	{
+		char tmp[16];
+		static char charging = ' ';
+		static int lastVal = -1;
+		static time_t nextSecCheck = 0;
+		struct timeval curTime;
+		gettimeofday(&curTime, NULL);
+		if (curTime.tv_sec > nextSecCheck)
+		{
+			char cap_s[4];
+#ifdef TW_CUSTOM_BATTERY_PATH
+			string capacity_file = EXPAND(TW_CUSTOM_BATTERY_PATH);
+			capacity_file += "/capacity";
+			FILE * cap = fopen(capacity_file.c_str(),"rt");
+#else
+			FILE * cap = fopen("/sys/class/power_supply/battery/capacity","rt");
+#endif
+			if (cap) {
+				fgets(cap_s, 4, cap);
+				fclose(cap);
+				lastVal = atoi(cap_s);
+				if (lastVal > 100)	lastVal = 101;
+				if (lastVal < 0)	lastVal = 0;
+			}
+#ifdef TW_CUSTOM_BATTERY_PATH
+			string status_file = EXPAND(TW_CUSTOM_BATTERY_PATH);
+			status_file += "/status";
+			cap = fopen(status_file.c_str(),"rt");
+#else
+			cap = fopen("/sys/class/power_supply/battery/status","rt");
+#endif
+			if (cap) {
+				fgets(cap_s, 2, cap);
+				fclose(cap);
+				if (cap_s[0] == 'C')
+					charging = '+';
+				else
+					charging = ' ';
+			}
+			nextSecCheck = curTime.tv_sec + 60;
+		}
+
+		sprintf(tmp, "%i%%%c", lastVal, charging);
+		value = tmp;
+		return 0;
+	}
+	return -1;
+}
+
+void DataManager::Output_Version(void)
+{
+#ifndef TW_OEM_BUILD
+	string Path;
+	char version[255];
+
+	std::string logDir = TWFunc::get_log_dir();
+	if (logDir.empty()) {
+		LOGINFO("Unable to find cache directory\n");
+		return;
+	}
+
+	std::string recoveryLogDir = logDir + "recovery/";
+
+	if (logDir == CACHE_LOGS_DIR) {
+		if (!PartitionManager.Mount_By_Path(CACHE_LOGS_DIR, false)) {
+			LOGINFO("Unable to mount '%s' to write version number.\n", Path.c_str());
+			return;
+		}
+
+		if (!TWFunc::Path_Exists(recoveryLogDir)) {
+			LOGINFO("Recreating %s folder.\n", recoveryLogDir.c_str());
+			if (!TWFunc::Create_Dir_Recursive(recoveryLogDir.c_str(), S_IRWXU | S_IRWXG | S_IWGRP | S_IXGRP, 0, 0)) {
+				LOGERR("DataManager::Output_Version -- Unable to make %s: %s\n", recoveryLogDir.c_str(), strerror(errno));
+				return;
+			}
+		}
+	}
+
+	std::string verPath = recoveryLogDir + ".version";
+	if (TWFunc::Path_Exists(verPath)) {
+		unlink(verPath.c_str());
+	}
+	FILE *fp = fopen(verPath.c_str(), "w");
+	if (fp == NULL) {
+		LOGINFO("Unable to open: %s. Data may be unmounted. Error: %s\n", verPath.c_str(), strerror(errno));
+		return;
+	}
+	strcpy(version, TW_VERSION_STR);
+	fwrite(version, sizeof(version[0]), strlen(version) / sizeof(version[0]), fp);
+	fclose(fp);
+	TWFunc::copy_file("/etc/recovery.fstab", recoveryLogDir + "recovery.fstab", 0644);
+	PartitionManager.Output_Storage_Fstab();
+	sync();
+	LOGINFO("Version number saved to '%s'\n", verPath.c_str());
+#endif
+}
+
+void DataManager::ReadSettingsFile(void)
+{
+#ifndef TW_OEM_BUILD
+	// Load up the values for TWRP - Sleep to let the card be ready
+	char mkdir_path[255], settings_file[255];
+	int is_enc, has_data_media;
+
+	GetValue(TW_IS_ENCRYPTED, is_enc);
+	GetValue(TW_HAS_DATA_MEDIA, has_data_media);
+
+	memset(mkdir_path, 0, sizeof(mkdir_path));
+	memset(settings_file, 0, sizeof(settings_file));
+	sprintf(mkdir_path, "%s%s", GetSettingsStoragePath().c_str(), GetStrValue(TW_RECOVERY_FOLDER_VAR).c_str());
+	sprintf(settings_file, "%s/%s", mkdir_path, TW_SETTINGS_FILE);
+
+	if (!PartitionManager.Mount_Settings_Storage(false))
+	{
+		usleep(500000);
+		if (!PartitionManager.Mount_Settings_Storage(false))
+			gui_msg(Msg(msg::kError, "unable_to_mount=Unable to mount {1}")(settings_file));
+	}
+
+	mkdir(mkdir_path, 0777);
+
+	LOGINFO("Attempt to load settings from settings file...\n");
+	LoadValues(settings_file);
+	Output_Version();
+#endif // ifdef TW_OEM_BUILD
+	PartitionManager.Mount_All_Storage();
+	update_tz_environment_variables();
+	TWFunc::Set_Brightness(GetStrValue("tw_brightness"));
+}
+
+string DataManager::GetCurrentStoragePath(void)
+{
+	return GetStrValue("tw_storage_path");
+}
+
+string DataManager::GetSettingsStoragePath(void)
+{
+	return GetStrValue("tw_settings_path");
+}
+
+void DataManager::Vibrate(const string& varName)
+{
+#ifndef TW_NO_HAPTICS
+	int vib_value = 0;
+	GetValue(varName, vib_value);
+	if (vib_value) {
+		vibrate(vib_value);
+	}
+#endif
+}
+
+
+void DataManager::LoadTWRPFolderInfo(void)
+{
+	string mainPath = GetCurrentStoragePath();
+	SetValue(TW_RECOVERY_FOLDER_VAR, TWFunc::Check_For_TwrpFolder());
+	mBackingFile = mainPath + GetStrValue(TW_RECOVERY_FOLDER_VAR) + '/' + TW_SETTINGS_FILE;
+}
diff --git a/variables.h b/variables.h
index a332d54291..408249a701 100755
--- a/variables.h
+++ b/variables.h
@@ -149,6 +149,8 @@
 #define TW_IS_SUPER                 "tw_is_super"
 #define TW_AUTO_REFLASHTWRP_VAR     "tw_auto_reflashtwrp"
 #define TW_CLOCK_POS                "tw_clock_pos"
+#define TW_STATUSBAR_INDENT_LEFT    "tw_status_indent_left"
+#define TW_STATUSBAR_INDENT_RIGHT   "tw_status_indent_right"
 
 // Theme versioning
 // version 2 requires theme to handle power button as action togglebacklight
diff --git a/variables.h.orig b/variables.h.orig
new file mode 100755
index 0000000000..a332d54291
--- /dev/null
+++ b/variables.h.orig
@@ -0,0 +1,182 @@
+/*
+ * Copyright (C) 2007 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef _VARIABLES_HEADER_
+#define _VARIABLES_HEADER_
+
+#define TW_MAIN_VERSION_STR       "3.6.2_11"
+#define TW_VERSION_STR TW_MAIN_VERSION_STR TW_DEVICE_VERSION
+#define TW_SETTINGS_FILE            ".twrps"
+#define TW_RECOVERY_NAME            "TWRP"
+#define TW_DEFAULT_RECOVERY_FOLDER  "/" TW_RECOVERY_NAME
+#define TW_USE_COMPRESSION_VAR      "tw_use_compression"
+#define TW_FILENAME                 "tw_filename"
+#define TW_ZIP_INDEX                "tw_zip_index"
+#define TW_ZIP_QUEUE_COUNT          "tw_zip_queue_count"
+
+#define MAX_BACKUP_NAME_LEN 64
+#define TW_BACKUP_TEXT              "tw_backup_text"
+#define TW_BACKUP_NAME		        "tw_backup_name"
+#define TW_BACKUP_SYSTEM_VAR        "tw_backup_system"
+#define TW_BACKUP_DATA_VAR          "tw_backup_data"
+#define TW_BACKUP_BOOT_VAR          "tw_backup_boot"
+#define TW_BACKUP_RECOVERY_VAR      "tw_backup_recovery"
+#define TW_BACKUP_CACHE_VAR         "tw_backup_cache"
+#define TW_BACKUP_ANDSEC_VAR        "tw_backup_andsec"
+#define TW_BACKUP_SDEXT_VAR         "tw_backup_sdext"
+#define TW_BACKUP_AVG_IMG_RATE      "tw_backup_avg_img_rate"
+#define TW_BACKUP_AVG_FILE_RATE     "tw_backup_avg_file_rate"
+#define TW_BACKUP_AVG_FILE_COMP_RATE    "tw_backup_avg_file_comp_rate"
+#define TW_BACKUP_SYSTEM_SIZE       "tw_backup_system_size"
+#define TW_BACKUP_DATA_SIZE         "tw_backup_data_size"
+#define TW_BACKUP_BOOT_SIZE         "tw_backup_boot_size"
+#define TW_BACKUP_RECOVERY_SIZE     "tw_backup_recovery_size"
+#define TW_BACKUP_CACHE_SIZE        "tw_backup_cache_size"
+#define TW_BACKUP_ANDSEC_SIZE       "tw_backup_andsec_size"
+#define TW_BACKUP_SDEXT_SIZE        "tw_backup_sdext_size"
+#define TW_STORAGE_FREE_SIZE        "tw_storage_free_size"
+#define TW_GENERATE_DIGEST_TEXT     "tw_generate_digest_text"
+
+#define TW_RESTORE_TEXT             "tw_restore_text"
+#define TW_RESTORE_SYSTEM_VAR       "tw_restore_system"
+#define TW_RESTORE_DATA_VAR         "tw_restore_data"
+#define TW_RESTORE_BOOT_VAR         "tw_restore_boot"
+#define TW_RESTORE_RECOVERY_VAR     "tw_restore_recovery"
+#define TW_RESTORE_CACHE_VAR        "tw_restore_cache"
+#define TW_RESTORE_ANDSEC_VAR       "tw_restore_andsec"
+#define TW_RESTORE_SDEXT_VAR        "tw_restore_sdext"
+#define TW_RESTORE_AVG_IMG_RATE     "tw_restore_avg_img_rate"
+#define TW_RESTORE_AVG_FILE_RATE    "tw_restore_avg_file_rate"
+#define TW_RESTORE_AVG_FILE_COMP_RATE    "tw_restore_avg_file_comp_rate"
+#define TW_RESTORE_FILE_DATE        "tw_restore_file_date"
+#define TW_VERIFY_DIGEST_TEXT       "tw_verify_digest_text"
+#define TW_UPDATE_SYSTEM_DETAILS_TEXT "tw_update_system_details_text"
+
+#define TW_VERSION_VAR              "tw_version"
+#define TW_GUI_SORT_ORDER           "tw_gui_sort_order"
+#define TW_ZIP_LOCATION_VAR         "tw_zip_location"
+#define TW_ZIP_INTERNAL_VAR         "tw_zip_internal"
+#define TW_ZIP_EXTERNAL_VAR         "tw_zip_external"
+#define TW_DISABLE_FREE_SPACE_VAR   "tw_disable_free_space"
+#define TW_FORCE_DIGEST_CHECK_VAR   "tw_force_digest_check"
+#define TW_SKIP_DIGEST_CHECK_VAR    "tw_skip_digest_check"
+#define TW_SKIP_DIGEST_GENERATE_VAR "tw_skip_digest_generate"
+#define TW_SKIP_DIGEST_CHECK_ZIP_VAR    "tw_skip_digest_check_zip"
+#define TW_SIGNED_ZIP_VERIFY_VAR    "tw_signed_zip_verify"
+#define TW_INSTALL_REBOOT_VAR       "tw_install_reboot"
+#define TW_TIME_ZONE_VAR            "tw_time_zone"
+#define TW_RM_RF_VAR                "tw_rm_rf"
+
+#define TW_BACKUPS_FOLDER_VAR       "tw_backups_folder"
+#define TW_RECOVERY_FOLDER_VAR      "tw_recovery_folder"
+
+#define TW_SDEXT_SIZE               "tw_sdext_size"
+#define TW_SWAP_SIZE                "tw_swap_size"
+#define TW_SDPART_FILE_SYSTEM       "tw_sdpart_file_system"
+#define TW_TIME_ZONE_GUISEL         "tw_time_zone_guisel"
+#define TW_TIME_ZONE_GUIOFFSET      "tw_time_zone_guioffset"
+#define TW_TIME_ZONE_GUIDST         "tw_time_zone_guidst"
+
+#define TW_ACTION_BUSY              "tw_busy"
+
+#define TW_ALLOW_PARTITION_SDCARD   "tw_allow_partition_sdcard"
+
+#define TW_SCREEN_OFF               "tw_screen_off"
+
+#define TW_REBOOT_SYSTEM            "tw_reboot_system"
+#define TW_REBOOT_RECOVERY          "tw_reboot_recovery"
+#define TW_REBOOT_POWEROFF          "tw_reboot_poweroff"
+#define TW_REBOOT_BOOTLOADER        "tw_reboot_bootloader"
+
+#define TW_USE_EXTERNAL_STORAGE     "tw_use_external_storage"
+#define TW_HAS_INTERNAL             "tw_has_internal"
+#define TW_INTERNAL_PATH            "tw_internal_path"         // /data/media or /internal
+#define TW_INTERNAL_MOUNT           "tw_internal_mount"        // /data or /internal
+#define TW_INTERNAL_LABEL           "tw_internal_label"        // data or internal
+#define TW_HAS_EXTERNAL             "tw_has_external"
+#define TW_EXTERNAL_PATH            "tw_external_path"         // /sdcard or /external/sdcard2
+#define TW_EXTERNAL_MOUNT           "tw_external_mount"        // /sdcard or /external
+#define TW_EXTERNAL_LABEL           "tw_external_label"        // sdcard or external
+
+#define TW_HAS_DATA_MEDIA           "tw_has_data_media"
+
+#define TW_HAS_BOOT_PARTITION       "tw_has_boot_partition"
+#define TW_HAS_RECOVERY_PARTITION   "tw_has_recovery_partition"
+#define TW_HAS_ANDROID_SECURE       "tw_has_android_secure"
+#define TW_HAS_SDEXT_PARTITION      "tw_has_sdext_partition"
+#define TW_HAS_USB_STORAGE          "tw_has_usb_storage"
+#define TW_NO_BATTERY_PERCENT       "tw_no_battery_percent"
+#define TW_POWER_BUTTON             "tw_power_button"
+#define TW_SIMULATE_ACTIONS         "tw_simulate_actions"
+#define TW_SIMULATE_FAIL            "tw_simulate_fail"
+#define TW_DONT_UNMOUNT_SYSTEM      "tw_dont_unmount_system"
+// #define TW_ALWAYS_RMRF              "tw_always_rmrf"
+
+#define TW_SHOW_DUMLOCK             "tw_show_dumlock"
+#define TW_HAS_INJECTTWRP           "tw_has_injecttwrp"
+#define TW_INJECT_AFTER_ZIP         "tw_inject_after_zip"
+#define TW_HAS_DATADATA             "tw_has_datadata"
+#define TW_FLASH_ZIP_IN_PLACE       "tw_flash_zip_in_place"
+#define TW_MIN_SYSTEM_SIZE          "50" // minimum system size to allow a reboot
+#define TW_MIN_SYSTEM_VAR           "tw_min_system"
+#define TW_DOWNLOAD_MODE            "tw_download_mode"
+#define TW_EDL_MODE                 "tw_edl_mode"
+#define TW_FASTBOOT_MODE            "tw_fastboot_mode"
+#define TW_IS_ENCRYPTED             "tw_is_encrypted"
+#define TW_IS_DECRYPTED             "tw_is_decrypted"
+#define TW_CRYPTO_PWTYPE            "tw_crypto_pwtype"
+#define TW_HAS_CRYPTO               "tw_has_crypto"
+#define TW_IS_FBE                   "tw_is_fbe"
+#define TW_CRYPTO_PASSWORD          "tw_crypto_password"
+#define TW_SDEXT_DISABLE_EXT4       "tw_sdext_disable_ext4"
+#define TW_MILITARY_TIME            "tw_military_time"
+#define TW_USE_SHA2                 "tw_use_sha2"
+#define TW_NO_SHA2                  "tw_no_sha2"
+#define TW_UNMOUNT_SYSTEM           "tw_unmount_system"
+#define TW_IS_SUPER                 "tw_is_super"
+#define TW_AUTO_REFLASHTWRP_VAR     "tw_auto_reflashtwrp"
+#define TW_CLOCK_POS                "tw_clock_pos"
+
+// Theme versioning
+// version 2 requires theme to handle power button as action togglebacklight
+// version 4 adds listbox support to reboot page
+// version 5 adds File Manager options, nano & Flash Current TWRP
+#define TW_THEME_VERSION 5
+
+// Also used:
+//   tw_boot_is_mountable
+//   tw_system_is_mountable
+//   tw_data_is_mountable
+//   tw_cache_is_mountable
+//   tw_sdcext_is_mountable
+//   tw_sdcint_is_mountable
+//   tw_sd-ext_is_mountable
+//   tw_sp1_is_mountable
+//   tw_sp2_is_mountable
+//   tw_sp3_is_mountable
+
+// Max archive size for tar backups before we split (1.5GB)
+#define MAX_ARCHIVE_SIZE 1610612736LLU
+//#define MAX_ARCHIVE_SIZE 52428800LLU // 50MB split for testing
+
+#ifndef CUSTOM_LUN_FILE
+#define CUSTOM_LUN_FILE "/sys/class/android_usb/android0/f_mass_storage/lun%d/file"
+#endif
+
+#define SCRIPT_FILE_TMP "/tmp/openrecoveryscript"
+#define TMP_LOG_FILE "/tmp/recovery.log"
+
+#endif  // _VARIABLES_HEADER_
